{"ast":null,"code":"/**\n * Returns detailed type as string (instead of just 'object' for arrays etc)\n * @private\n * @param {any} value js value\n * @returns {String} type of value\n * @example\n * typeOf({}); // 'object'\n * typeOf([]); // 'array'\n * typeOf(function() {}); // 'function'\n * typeOf(/a/); // 'regexp'\n * typeOf(new Date()); // 'date'\n * typeOf(null); // 'null'\n * typeOf(undefined); // 'undefined'\n * typeOf('a'); // 'string'\n * typeOf(1); // 'number'\n * typeOf(true); // 'boolean'\n * typeOf(new Map()); // 'map'\n * typeOf(new Set()); // 'map'\n */\nfunction typeOf(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value !== Object(value)) {\n    return typeof value;\n  }\n  return {}.toString.call(value).slice(8, -1).toLowerCase();\n}\n\n/**\n * Checks if input string is empty\n * @param  {String} input text input\n * @return {Boolean} true if no input\n */\nfunction isEmpty(input) {\n  if (typeOf(input) !== 'string') {\n    return true;\n  }\n  return !input.length;\n}\n\n/**\n * Takes a character and a unicode range. Returns true if the char is in the range.\n * @param  {String}  char  unicode character\n * @param  {Number}  start unicode start range\n * @param  {Number}  end   unicode end range\n * @return {Boolean}\n */\nfunction isCharInRange(char = '', start, end) {\n  if (isEmpty(char)) return false;\n  const code = char.charCodeAt(0);\n  return start <= code && code <= end;\n}\nconst VERSION = '5.3.1';\nconst TO_KANA_METHODS = {\n  HIRAGANA: 'toHiragana',\n  KATAKANA: 'toKatakana'\n};\nconst ROMANIZATIONS = {\n  HEPBURN: 'hepburn'\n};\n/**\n * Default config for WanaKana, user passed options will be merged with these\n * @type {DefaultOptions}\n * @name DefaultOptions\n * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ゐ and ゑ.\n * @example\n * toHiragana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()\n * @example\n * toHiragana('only convert the katakana: ヒラガナ', { passRomaji: true })\n * // => \"only convert the katakana: ひらがな\"\n * @property {Boolean} [convertLongVowelMark=true] - Set to false to prevent conversions of 'ー' to extended vowels with toHiragana()\n * @example\n * toHiragana('ラーメン', { convertLongVowelMark: false });\n * // => 'らーめん\n * @property {Boolean} [upcaseKatakana=false] - Set to true to convert katakana to uppercase using toRomaji()\n * @example\n * toRomaji('ひらがな カタカナ', { upcaseKatakana: true })\n * // => \"hiragana KATAKANA\"\n * @property {Boolean | 'toHiragana' | 'toKatakana'} [IMEMode=false] - Set to true, 'toHiragana', or 'toKatakana' to handle conversion while it is being typed.\n * @property {'hepburn'} [romanization='hepburn'] - choose toRomaji() romanization map (currently only 'hepburn')\n * @property {Object.<String, String>} [customKanaMapping] - custom map will be merged with default conversion\n * @example\n * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'Bana' }) };\n * // => 'わにBanaに'\n * @property {Object.<String, String>} [customRomajiMapping] - custom map will be merged with default conversion\n * @example\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' }) };\n * // => 'tuzigili'\n */\nconst DEFAULT_OPTIONS = {\n  useObsoleteKana: false,\n  passRomaji: false,\n  convertLongVowelMark: true,\n  upcaseKatakana: false,\n  IMEMode: false,\n  romanization: ROMANIZATIONS.HEPBURN\n};\nconst LATIN_UPPERCASE_START = 0x41;\nconst LATIN_UPPERCASE_END = 0x5a;\nconst LOWERCASE_ZENKAKU_START = 0xff41;\nconst LOWERCASE_ZENKAKU_END = 0xff5a;\nconst UPPERCASE_ZENKAKU_START = 0xff21;\nconst UPPERCASE_ZENKAKU_END = 0xff3a;\nconst HIRAGANA_START = 0x3041;\nconst HIRAGANA_END = 0x3096;\nconst KATAKANA_START = 0x30a1;\nconst KATAKANA_END = 0x30fc;\nconst KANJI_START = 0x4e00;\nconst KANJI_END = 0x9faf;\nconst KANJI_ITERATION_MARK = 0x3005; // 々\nconst PROLONGED_SOUND_MARK = 0x30fc; // ー\nconst KANA_SLASH_DOT = 0x30fb; // ・\nconst ZENKAKU_NUMBERS = [0xff10, 0xff19];\nconst ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];\nconst ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];\nconst ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];\nconst ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];\nconst ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];\nconst ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];\nconst ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];\nconst HIRAGANA_CHARS = [0x3040, 0x309f];\nconst KATAKANA_CHARS = [0x30a0, 0x30ff];\nconst HANKAKU_KATAKANA = [0xff66, 0xff9f];\nconst KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];\nconst KANA_PUNCTUATION = [0xff61, 0xff65];\nconst CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];\nconst COMMON_CJK = [0x4e00, 0x9fff];\nconst RARE_CJK = [0x3400, 0x4dbf];\nconst KANA_RANGES = [HIRAGANA_CHARS, KATAKANA_CHARS, KANA_PUNCTUATION, HANKAKU_KATAKANA];\nconst JA_PUNCTUATION_RANGES = [CJK_SYMBOLS_PUNCTUATION, KANA_PUNCTUATION, KATAKANA_PUNCTUATION, ZENKAKU_PUNCTUATION_1, ZENKAKU_PUNCTUATION_2, ZENKAKU_PUNCTUATION_3, ZENKAKU_PUNCTUATION_4, ZENKAKU_SYMBOLS_CURRENCY];\n// All Japanese unicode start and end ranges\n// Includes kanji, kana, zenkaku latin chars, punctuation, and number ranges.\nconst JAPANESE_RANGES = [...KANA_RANGES, ...JA_PUNCTUATION_RANGES, ZENKAKU_UPPERCASE, ZENKAKU_LOWERCASE, ZENKAKU_NUMBERS, COMMON_CJK, RARE_CJK];\nconst MODERN_ENGLISH = [0x0000, 0x007f];\nconst HEPBURN_MACRON_RANGES = [[0x0100, 0x0101], [0x0112, 0x0113], [0x012a, 0x012b], [0x014c, 0x014d], [0x016a, 0x016b] // Ū ū\n];\nconst SMART_QUOTE_RANGES = [[0x2018, 0x2019], [0x201c, 0x201d] // “ ”\n];\nconst ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];\nconst EN_PUNCTUATION_RANGES = [[0x20, 0x2f], [0x3a, 0x3f], [0x5b, 0x60], [0x7b, 0x7e], ...SMART_QUOTE_RANGES];\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanese(char = '') {\n  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\n/**\n * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.”\n * @param  {String} [input=''] text\n * @param  {RegExp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if passes checks\n * @example\n * isJapanese('泣き虫')\n * // => true\n * isJapanese('あア')\n * // => true\n * isJapanese('２月') // Zenkaku numbers allowed\n * // => true\n * isJapanese('泣き虫。！〜＄') // Zenkaku/JA punctuation\n * // => true\n * isJapanese('泣き虫.!~$') // Latin punctuation fails\n * // => false\n * isJapanese('A泣き虫')\n * // => false\n * isJapanese('≪偽括弧≫', /[≪≫]/);\n * // => true\n */\nfunction isJapanese(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input) ? false : [...input].every(char => {\n    const isJa = isCharJapanese(char);\n    return !augmented ? isJa : isJa || allowed.test(char);\n  });\n}\nvar safeIsNaN = Number.isNaN || function ponyfill(value) {\n  return typeof value === 'number' && value !== value;\n};\nfunction isEqual(first, second) {\n  if (first === second) {\n    return true;\n  }\n  if (safeIsNaN(first) && safeIsNaN(second)) {\n    return true;\n  }\n  return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n  for (var i = 0; i < newInputs.length; i++) {\n    if (!isEqual(newInputs[i], lastInputs[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction memoizeOne(resultFn, isEqual) {\n  if (isEqual === void 0) {\n    isEqual = areInputsEqual;\n  }\n  var cache = null;\n  function memoized() {\n    var newArgs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n    if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n      return cache.lastResult;\n    }\n    var lastResult = resultFn.apply(this, newArgs);\n    cache = {\n      lastResult: lastResult,\n      lastArgs: newArgs,\n      lastThis: this\n    };\n    return lastResult;\n  }\n  memoized.clear = function clear() {\n    cache = null;\n  };\n  return memoized;\n}\nvar has = Object.prototype.hasOwnProperty;\nfunction find(iter, tar, key) {\n  for (key of iter.keys()) {\n    if (dequal(key, tar)) return key;\n  }\n}\nfunction dequal(foo, bar) {\n  var ctor, len, tmp;\n  if (foo === bar) return true;\n  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n    if (ctor === Date) return foo.getTime() === bar.getTime();\n    if (ctor === RegExp) return foo.toString() === bar.toString();\n    if (ctor === Array) {\n      if ((len = foo.length) === bar.length) {\n        while (len-- && dequal(foo[len], bar[len]));\n      }\n      return len === -1;\n    }\n    if (ctor === Set) {\n      if (foo.size !== bar.size) {\n        return false;\n      }\n      for (len of foo) {\n        tmp = len;\n        if (tmp && typeof tmp === 'object') {\n          tmp = find(bar, tmp);\n          if (!tmp) return false;\n        }\n        if (!bar.has(tmp)) return false;\n      }\n      return true;\n    }\n    if (ctor === Map) {\n      if (foo.size !== bar.size) {\n        return false;\n      }\n      for (len of foo) {\n        tmp = len[0];\n        if (tmp && typeof tmp === 'object') {\n          tmp = find(bar, tmp);\n          if (!tmp) return false;\n        }\n        if (!dequal(len[1], bar.get(tmp))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (ctor === ArrayBuffer) {\n      foo = new Uint8Array(foo);\n      bar = new Uint8Array(bar);\n    } else if (ctor === DataView) {\n      if ((len = foo.byteLength) === bar.byteLength) {\n        while (len-- && foo.getInt8(len) === bar.getInt8(len));\n      }\n      return len === -1;\n    }\n    if (ArrayBuffer.isView(foo)) {\n      if ((len = foo.byteLength) === bar.byteLength) {\n        while (len-- && foo[len] === bar[len]);\n      }\n      return len === -1;\n    }\n    if (!ctor || typeof foo === 'object') {\n      len = 0;\n      for (ctor in foo) {\n        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n      }\n      return Object.keys(bar).length === len;\n    }\n  }\n  return foo !== foo && bar !== bar;\n}\n\n/**\n * Easy re-use of merging with default options\n * @param {Object} opts user options\n * @returns user options merged over default options\n */\nconst mergeWithDefaultOptions = (opts = {}) => Object.assign({}, DEFAULT_OPTIONS, opts);\nfunction applyMapping(string, mapping, convertEnding) {\n  const root = mapping;\n  function nextSubtree(tree, nextChar) {\n    const subtree = tree[nextChar];\n    if (subtree === undefined) {\n      return undefined;\n    }\n    // if the next child node does not have a node value, set its node value to the input\n    return Object.assign({\n      '': tree[''] + nextChar\n    }, tree[nextChar]);\n  }\n  function newChunk(remaining, currentCursor) {\n    // start parsing a new chunk\n    const firstChar = remaining.charAt(0);\n    return parse(Object.assign({\n      '': firstChar\n    }, root[firstChar]), remaining.slice(1), currentCursor, currentCursor + 1);\n  }\n  function parse(tree, remaining, lastCursor, currentCursor) {\n    if (!remaining) {\n      if (convertEnding || Object.keys(tree).length === 1) {\n        // nothing more to consume, just commit the last chunk and return it\n        // so as to not have an empty element at the end of the result\n        return tree[''] ? [[lastCursor, currentCursor, tree['']]] : [];\n      }\n      // if we don't want to convert the ending, because there are still possible continuations\n      // return null as the final node value\n      return [[lastCursor, currentCursor, null]];\n    }\n    if (Object.keys(tree).length === 1) {\n      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));\n    }\n    const subtree = nextSubtree(tree, remaining.charAt(0));\n    if (subtree === undefined) {\n      return [[lastCursor, currentCursor, tree['']]].concat(newChunk(remaining, currentCursor));\n    }\n    // continue current branch\n    return parse(subtree, remaining.slice(1), lastCursor, currentCursor + 1);\n  }\n  return newChunk(string, 0);\n}\n// transform the tree, so that for example hepburnTree['ゔ']['ぁ'][''] === 'va'\n// or kanaTree['k']['y']['a'][''] === 'きゃ'\nfunction transform(tree) {\n  return Object.entries(tree).reduce((map, [char, subtree]) => {\n    const endOfBranch = typeOf(subtree) === 'string';\n    // eslint-disable-next-line no-param-reassign\n    map[char] = endOfBranch ? {\n      '': subtree\n    } : transform(subtree);\n    return map;\n  }, {});\n}\nfunction getSubTreeOf(tree, string) {\n  return string.split('').reduce((correctSubTree, char) => {\n    if (correctSubTree[char] === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      correctSubTree[char] = {};\n    }\n    return correctSubTree[char];\n  }, tree);\n}\n/**\n * Creates a custom mapping tree, returns a function that accepts a defaultMap which the newly created customMapping will be merged with and returned\n * (customMap) => (defaultMap) => mergedMap\n * @param  {Object} customMap { 'ka' : 'な' }\n * @return {Function} (defaultMap) => defaultMergedWithCustomMap\n * @example\n * const sillyMap = createCustomMapping({ 'ちゃ': 'time', '茎': 'cookie'　});\n * // sillyMap is passed defaultMapping to merge with when called in toRomaji()\n * toRomaji(\"It's 茎 ちゃ よ\", { customRomajiMapping: sillyMap });\n * // => 'It's cookie time yo';\n */\nfunction createCustomMapping(customMap = {}) {\n  const customTree = {};\n  if (typeOf(customMap) === 'object') {\n    Object.entries(customMap).forEach(([roma, kana]) => {\n      let subTree = customTree;\n      roma.split('').forEach(char => {\n        if (subTree[char] === undefined) {\n          subTree[char] = {};\n        }\n        subTree = subTree[char];\n      });\n      subTree[''] = kana;\n    });\n  }\n  return function makeMap(map) {\n    const mapCopy = JSON.parse(JSON.stringify(map));\n    function transformMap(mapSubtree, customSubtree) {\n      if (mapSubtree === undefined || typeOf(mapSubtree) === 'string') {\n        return customSubtree;\n      }\n      return Object.entries(customSubtree).reduce((newSubtree, [char, subtree]) => {\n        // eslint-disable-next-line no-param-reassign\n        newSubtree[char] = transformMap(mapSubtree[char], subtree);\n        return newSubtree;\n      }, mapSubtree);\n    }\n    return transformMap(mapCopy, customTree);\n  };\n}\n// allow consumer to pass either function or object as customMapping\nfunction mergeCustomMapping(map, customMapping) {\n  if (!customMapping) {\n    return map;\n  }\n  return typeOf(customMapping) === 'function' ? customMapping(map) : createCustomMapping(customMapping)(map);\n}\n\n// NOTE: not exactly kunrei shiki, for example ぢゃ -> dya instead of zya, to avoid name clashing\n/* eslint-disable */\n// prettier-ignore\nconst BASIC_KUNREI = {\n  a: 'あ',\n  i: 'い',\n  u: 'う',\n  e: 'え',\n  o: 'お',\n  k: {\n    a: 'か',\n    i: 'き',\n    u: 'く',\n    e: 'け',\n    o: 'こ'\n  },\n  s: {\n    a: 'さ',\n    i: 'し',\n    u: 'す',\n    e: 'せ',\n    o: 'そ'\n  },\n  t: {\n    a: 'た',\n    i: 'ち',\n    u: 'つ',\n    e: 'て',\n    o: 'と'\n  },\n  n: {\n    a: 'な',\n    i: 'に',\n    u: 'ぬ',\n    e: 'ね',\n    o: 'の'\n  },\n  h: {\n    a: 'は',\n    i: 'ひ',\n    u: 'ふ',\n    e: 'へ',\n    o: 'ほ'\n  },\n  m: {\n    a: 'ま',\n    i: 'み',\n    u: 'む',\n    e: 'め',\n    o: 'も'\n  },\n  y: {\n    a: 'や',\n    u: 'ゆ',\n    o: 'よ'\n  },\n  r: {\n    a: 'ら',\n    i: 'り',\n    u: 'る',\n    e: 'れ',\n    o: 'ろ'\n  },\n  w: {\n    a: 'わ',\n    i: 'ゐ',\n    e: 'ゑ',\n    o: 'を'\n  },\n  g: {\n    a: 'が',\n    i: 'ぎ',\n    u: 'ぐ',\n    e: 'げ',\n    o: 'ご'\n  },\n  z: {\n    a: 'ざ',\n    i: 'じ',\n    u: 'ず',\n    e: 'ぜ',\n    o: 'ぞ'\n  },\n  d: {\n    a: 'だ',\n    i: 'ぢ',\n    u: 'づ',\n    e: 'で',\n    o: 'ど'\n  },\n  b: {\n    a: 'ば',\n    i: 'び',\n    u: 'ぶ',\n    e: 'べ',\n    o: 'ぼ'\n  },\n  p: {\n    a: 'ぱ',\n    i: 'ぴ',\n    u: 'ぷ',\n    e: 'ぺ',\n    o: 'ぽ'\n  },\n  v: {\n    a: 'ゔぁ',\n    i: 'ゔぃ',\n    u: 'ゔ',\n    e: 'ゔぇ',\n    o: 'ゔぉ'\n  }\n};\nconst SPECIAL_SYMBOLS$1 = {\n  '.': '。',\n  ',': '、',\n  ':': '：',\n  '/': '・',\n  '!': '！',\n  '?': '？',\n  '~': '〜',\n  '-': 'ー',\n  '‘': '「',\n  '’': '」',\n  '“': '『',\n  '”': '』',\n  '[': '［',\n  ']': '］',\n  '(': '（',\n  ')': '）',\n  '{': '｛',\n  '}': '｝'\n};\nconst CONSONANTS = {\n  k: 'き',\n  s: 'し',\n  t: 'ち',\n  n: 'に',\n  h: 'ひ',\n  m: 'み',\n  r: 'り',\n  g: 'ぎ',\n  z: 'じ',\n  d: 'ぢ',\n  b: 'び',\n  p: 'ぴ',\n  v: 'ゔ',\n  q: 'く',\n  f: 'ふ'\n};\nconst SMALL_Y$1 = {\n  ya: 'ゃ',\n  yi: 'ぃ',\n  yu: 'ゅ',\n  ye: 'ぇ',\n  yo: 'ょ'\n};\nconst SMALL_VOWELS = {\n  a: 'ぁ',\n  i: 'ぃ',\n  u: 'ぅ',\n  e: 'ぇ',\n  o: 'ぉ'\n};\n// typing one should be the same as having typed the other instead\nconst ALIASES = {\n  sh: 'sy',\n  ch: 'ty',\n  cy: 'ty',\n  chy: 'ty',\n  shy: 'sy',\n  j: 'zy',\n  jy: 'zy',\n  // exceptions to above rules\n  shi: 'si',\n  chi: 'ti',\n  tsu: 'tu',\n  ji: 'zi',\n  fu: 'hu'\n};\n// xtu -> っ\nconst SMALL_LETTERS = Object.assign({\n  tu: 'っ',\n  wa: 'ゎ',\n  ka: 'ヵ',\n  ke: 'ヶ'\n}, SMALL_VOWELS, SMALL_Y$1);\n// don't follow any notable patterns\nconst SPECIAL_CASES = {\n  yi: 'い',\n  wu: 'う',\n  ye: 'いぇ',\n  wi: 'うぃ',\n  we: 'うぇ',\n  kwa: 'くぁ',\n  whu: 'う',\n  // because it's not thya for てゃ but tha\n  // and tha is not てぁ, but てゃ\n  tha: 'てゃ',\n  thu: 'てゅ',\n  tho: 'てょ',\n  dha: 'でゃ',\n  dhu: 'でゅ',\n  dho: 'でょ'\n};\nconst AIUEO_CONSTRUCTIONS = {\n  wh: 'う',\n  kw: 'く',\n  qw: 'く',\n  q: 'く',\n  gw: 'ぐ',\n  sw: 'す',\n  ts: 'つ',\n  th: 'て',\n  tw: 'と',\n  dh: 'で',\n  dw: 'ど',\n  fw: 'ふ',\n  f: 'ふ'\n};\n/* eslint-enable */\nfunction createRomajiToKanaMap$1() {\n  const kanaTree = transform(BASIC_KUNREI);\n  // pseudo partial application\n  const subtreeOf = string => getSubTreeOf(kanaTree, string);\n  // add tya, sya, etc.\n  Object.entries(CONSONANTS).forEach(([consonant, yKana]) => {\n    Object.entries(SMALL_Y$1).forEach(([roma, kana]) => {\n      // for example kyo -> き + ょ\n      subtreeOf(consonant + roma)[''] = yKana + kana;\n    });\n  });\n  Object.entries(SPECIAL_SYMBOLS$1).forEach(([symbol, jsymbol]) => {\n    subtreeOf(symbol)[''] = jsymbol;\n  });\n  // things like うぃ, くぃ, etc.\n  Object.entries(AIUEO_CONSTRUCTIONS).forEach(([consonant, aiueoKana]) => {\n    Object.entries(SMALL_VOWELS).forEach(([vowel, kana]) => {\n      const subtree = subtreeOf(consonant + vowel);\n      subtree[''] = aiueoKana + kana;\n    });\n  });\n  // different ways to write ん\n  ['n', \"n'\", 'xn'].forEach(nChar => {\n    subtreeOf(nChar)[''] = 'ん';\n  });\n  // c is equivalent to k, but not for chi, cha, etc. that's why we have to make a copy of k\n  kanaTree.c = JSON.parse(JSON.stringify(kanaTree.k));\n  Object.entries(ALIASES).forEach(([string, alternative]) => {\n    const allExceptLast = string.slice(0, string.length - 1);\n    const last = string.charAt(string.length - 1);\n    const parentTree = subtreeOf(allExceptLast);\n    // copy to avoid recursive containment\n    parentTree[last] = JSON.parse(JSON.stringify(subtreeOf(alternative)));\n  });\n  function getAlternatives(string) {\n    return [...Object.entries(ALIASES), ...[['c', 'k']]].reduce((list, [alt, roma]) => string.startsWith(roma) ? list.concat(string.replace(roma, alt)) : list, []);\n  }\n  Object.entries(SMALL_LETTERS).forEach(([kunreiRoma, kana]) => {\n    const last = char => char.charAt(char.length - 1);\n    const allExceptLast = chars => chars.slice(0, chars.length - 1);\n    const xRoma = `x${kunreiRoma}`;\n    const xSubtree = subtreeOf(xRoma);\n    xSubtree[''] = kana;\n    // ltu -> xtu -> っ\n    const parentTree = subtreeOf(`l${allExceptLast(kunreiRoma)}`);\n    parentTree[last(kunreiRoma)] = xSubtree;\n    // ltsu -> ltu -> っ\n    getAlternatives(kunreiRoma).forEach(altRoma => {\n      ['l', 'x'].forEach(prefix => {\n        const altParentTree = subtreeOf(prefix + allExceptLast(altRoma));\n        altParentTree[last(altRoma)] = subtreeOf(prefix + kunreiRoma);\n      });\n    });\n  });\n  Object.entries(SPECIAL_CASES).forEach(([string, kana]) => {\n    subtreeOf(string)[''] = kana;\n  });\n  // add kka, tta, etc.\n  function addTsu(tree) {\n    return Object.entries(tree).reduce((tsuTree, [key, value]) => {\n      if (!key) {\n        // we have reached the bottom of this branch\n        // eslint-disable-next-line no-param-reassign\n        tsuTree[key] = `っ${value}`;\n      } else {\n        // more subtrees\n        // eslint-disable-next-line no-param-reassign\n        tsuTree[key] = addTsu(value);\n      }\n      return tsuTree;\n    }, {});\n  }\n  // have to explicitly name c here, because we made it a copy of k, not a reference\n  [...Object.keys(CONSONANTS), 'c', 'y', 'w', 'j'].forEach(consonant => {\n    const subtree = kanaTree[consonant];\n    subtree[consonant] = addTsu(subtree);\n  });\n  // nn should not be っん\n  delete kanaTree.n.n;\n  // solidify the results, so that there there is referential transparency within the tree\n  return Object.freeze(JSON.parse(JSON.stringify(kanaTree)));\n}\nlet romajiToKanaMap = null;\nfunction getRomajiToKanaTree() {\n  if (romajiToKanaMap == null) {\n    romajiToKanaMap = createRomajiToKanaMap$1();\n  }\n  return romajiToKanaMap;\n}\nconst USE_OBSOLETE_KANA_MAP = createCustomMapping({\n  wi: 'ゐ',\n  we: 'ゑ'\n});\nfunction IME_MODE_MAP(map) {\n  // in IME mode, we do not want to convert single ns\n  const mapCopy = JSON.parse(JSON.stringify(map));\n  mapCopy.n.n = {\n    '': 'ん'\n  };\n  mapCopy.n[' '] = {\n    '': 'ん'\n  };\n  return mapCopy;\n}\n\n/**\n * Tests if char is in English unicode uppercase range\n * @param  {String} char\n * @return {Boolean}\n */\nfunction isCharUpperCase(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharInRange(char, LATIN_UPPERCASE_START, LATIN_UPPERCASE_END);\n}\n\n/**\n * Returns true if char is 'ー'\n * @param  {String} char to test\n * @return {Boolean}\n */\nfunction isCharLongDash(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;\n}\n\n/**\n * Tests if char is '・'\n * @param  {String} char\n * @return {Boolean} true if '・'\n */\nfunction isCharSlashDot(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === KANA_SLASH_DOT;\n}\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharHiragana(char = '') {\n  if (isEmpty(char)) return false;\n  if (isCharLongDash(char)) return true;\n  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);\n}\n\n/**\n * Convert [Hiragana](https://en.wikipedia.org/wiki/Hiragana) to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * Passes through any non-hiragana chars\n * @private\n * @param  {String} [input=''] text input\n * @return {String} converted text\n * @example\n * hiraganaToKatakana('ひらがな')\n * // => \"ヒラガナ\"\n * hiraganaToKatakana('ひらがな is a type of kana')\n * // => \"ヒラガナ is a type of kana\"\n */\nfunction hiraganaToKatakana(input = '') {\n  const kata = [];\n  input.split('').forEach(char => {\n    // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n    if (isCharLongDash(char) || isCharSlashDot(char)) {\n      kata.push(char);\n    } else if (isCharHiragana(char)) {\n      // Shift charcode.\n      const code = char.charCodeAt(0) + (KATAKANA_START - HIRAGANA_START);\n      const kataChar = String.fromCharCode(code);\n      kata.push(kataChar);\n    } else {\n      // Pass non-hiragana chars through\n      kata.push(char);\n    }\n  });\n  return kata.join('');\n}\n\n// memoize and deeply compare args so we only recreate when necessary\nconst createRomajiToKanaMap = memoizeOne((IMEMode, useObsoleteKana, customKanaMapping) => {\n  let map = getRomajiToKanaTree();\n  map = IMEMode ? IME_MODE_MAP(map) : map;\n  map = useObsoleteKana ? USE_OBSOLETE_KANA_MAP(map) : map;\n  if (customKanaMapping) {\n    map = mergeCustomMapping(map, customKanaMapping);\n  }\n  return map;\n}, dequal);\n/**\n * Convert [Romaji](https://en.wikipedia.org/wiki/Romaji) to [Kana](https://en.wikipedia.org/wiki/Kana), lowercase text will result in [Hiragana](https://en.wikipedia.org/wiki/Hiragana) and uppercase text will result in [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @param  {Object.<string, string>} [map] custom mapping\n * @return {String} converted text\n * @example\n * toKana('onaji BUTTSUUJI')\n * // => 'おなじ ブッツウジ'\n * toKana('ONAJI buttsuuji')\n * // => 'オナジ ぶっつうじ'\n * toKana('座禅‘zazen’スタイル')\n * // => '座禅「ざぜん」スタイル'\n * toKana('batsuge-mu')\n * // => 'ばつげーむ'\n * toKana('!?.:/,~-‘’“”[](){}') // Punctuation conversion\n * // => '！？。：・、〜ー「」『』［］（）｛｝'\n * toKana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'bana' } });\n * // => 'わにbanaに'\n */\nfunction toKana(input = '', options = {}, map) {\n  let config;\n  if (!map) {\n    config = mergeWithDefaultOptions(options);\n    map = createRomajiToKanaMap(config.IMEMode, config.useObsoleteKana, config.customKanaMapping);\n  } else {\n    config = options;\n  }\n  // throw away the substring index information and just concatenate all the kana\n  return splitIntoConvertedKana(input, config, map).map(kanaToken => {\n    const [start, end, kana] = kanaToken;\n    if (kana === null) {\n      // haven't converted the end of the string, since we are in IME mode\n      return input.slice(start);\n    }\n    const enforceHiragana = config.IMEMode === TO_KANA_METHODS.HIRAGANA;\n    const enforceKatakana = config.IMEMode === TO_KANA_METHODS.KATAKANA || [...input.slice(start, end)].every(isCharUpperCase);\n    return enforceHiragana || !enforceKatakana ? kana : hiraganaToKatakana(kana);\n  }).join('');\n}\n/**\n *\n * @private\n * @param {String} [input=''] input text\n * @param {DefaultOptions} [options=defaultOptions] toKana options\n * @param {Object} [map] custom mapping\n * @returns {Array[]} [[start, end, token]]\n * @example\n * splitIntoConvertedKana('buttsuuji')\n * // => [[0, 2, 'ぶ'], [2, 6, 'っつ'], [6, 7, 'う'], [7, 9, 'じ']]\n */\nfunction splitIntoConvertedKana(input = '', options = {}, map) {\n  const {\n    IMEMode,\n    useObsoleteKana,\n    customKanaMapping\n  } = options;\n  if (!map) {\n    map = createRomajiToKanaMap(IMEMode, useObsoleteKana, customKanaMapping);\n  }\n  return applyMapping(input.toLowerCase(), map, !IMEMode);\n}\nlet LISTENERS = [];\n/**\n * Automagically replaces input values with converted text to kana\n * @param  {defaultOptions} [options] user config overrides, default conversion is toKana()\n * @return {Function} event handler with bound options\n * @private\n */\nfunction makeOnInput(options) {\n  let prevInput;\n  // Enforce IMEMode if not already specified\n  const mergedConfig = Object.assign({}, mergeWithDefaultOptions(options), {\n    IMEMode: options.IMEMode || true\n  });\n  const preConfiguredMap = createRomajiToKanaMap(mergedConfig.IMEMode, mergedConfig.useObsoleteKana, mergedConfig.customKanaMapping);\n  const triggers = [...Object.keys(preConfiguredMap), ...Object.keys(preConfiguredMap).map(char => char.toUpperCase())];\n  return function onInput({\n    target\n  }) {\n    if (target.value !== prevInput && target.dataset.ignoreComposition !== 'true') {\n      convertInput(target, mergedConfig, preConfiguredMap, triggers);\n    }\n  };\n}\nfunction convertInput(target, options, map, triggers, prevInput) {\n  const [head, textToConvert, tail] = splitInput(target.value, target.selectionEnd, triggers);\n  const convertedText = toKana(textToConvert, options, map);\n  const changed = textToConvert !== convertedText;\n  if (changed) {\n    const newCursor = head.length + convertedText.length;\n    const newValue = head + convertedText + tail;\n    // eslint-disable-next-line no-param-reassign\n    target.value = newValue;\n    if (tail.length) {\n      // push later on event loop (otherwise mid-text insertion can be 1 char too far to the right)\n      setTimeout(() => target.setSelectionRange(newCursor, newCursor), 1);\n    } else {\n      target.setSelectionRange(newCursor, newCursor);\n    }\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    target.value;\n  }\n}\nfunction onComposition({\n  type,\n  target,\n  data\n}) {\n  // navigator.platform is not 100% reliable for singling out all OS,\n  // but for determining desktop \"Mac OS\" it is effective enough.\n  const isMacOS = /Mac/.test(window.navigator && window.navigator.platform);\n  // We don't want to ignore on Android:\n  // https://github.com/WaniKani/WanaKana/issues/82\n  // But MacOS IME auto-closes if we don't ignore:\n  // https://github.com/WaniKani/WanaKana/issues/71\n  // Other platform Japanese IMEs pass through happily\n  if (isMacOS) {\n    if (type === 'compositionupdate' && isJapanese(data)) {\n      // eslint-disable-next-line no-param-reassign\n      target.dataset.ignoreComposition = 'true';\n    }\n    if (type === 'compositionend') {\n      // eslint-disable-next-line no-param-reassign\n      target.dataset.ignoreComposition = 'false';\n    }\n  }\n}\nfunction trackListeners(id, inputHandler, compositionHandler) {\n  LISTENERS = LISTENERS.concat({\n    id,\n    inputHandler,\n    compositionHandler\n  });\n}\nfunction untrackListeners({\n  id: targetId\n}) {\n  LISTENERS = LISTENERS.filter(({\n    id\n  }) => id !== targetId);\n}\nfunction findListeners(el) {\n  return el && LISTENERS.find(({\n    id\n  }) => id === el.getAttribute('data-wanakana-id'));\n}\n// Handle non-terminal inserted input conversion:\n// | -> わ| -> わび| -> わ|び -> わs|び -> わsh|び -> わshi|び -> わし|び\n// or multiple ambiguous positioning (to select which \"s\" to work from)\n// こsこs|こsこ -> こsこso|こsこ -> こsこそ|こsこ\nfunction splitInput(text = '', cursor = 0, triggers = []) {\n  let head;\n  let toConvert;\n  let tail;\n  if (cursor === 0 && triggers.includes(text[0])) {\n    [head, toConvert, tail] = workFromStart(text, triggers);\n  } else if (cursor > 0) {\n    [head, toConvert, tail] = workBackwards(text, cursor);\n  } else {\n    [head, toConvert] = takeWhileAndSlice(text, char => !triggers.includes(char));\n    [toConvert, tail] = takeWhileAndSlice(toConvert, char => !isJapanese(char));\n  }\n  return [head, toConvert, tail];\n}\nfunction workFromStart(text, catalystChars) {\n  return ['', ...takeWhileAndSlice(text, char => catalystChars.includes(char) || !isJapanese(char, /[0-9]/))];\n}\nfunction workBackwards(text = '', startIndex = 0) {\n  const [toConvert, head] = takeWhileAndSlice([...text.slice(0, startIndex)].reverse(), char => !isJapanese(char));\n  return [head.reverse().join(''), toConvert.split('').reverse().join(''), text.slice(startIndex)];\n}\nfunction takeWhileAndSlice(source = {}, predicate = x => !!x) {\n  const result = [];\n  const {\n    length\n  } = source;\n  let i = 0;\n  while (i < length && predicate(source[i], i)) {\n    result.push(source[i]);\n    i += 1;\n  }\n  return [result.join(''), source.slice(i)];\n}\n\n/* eslint-disable no-console */\nconst onInput = ({\n  target: {\n    value,\n    selectionStart,\n    selectionEnd\n  }\n}) => console.log('input:', {\n  value,\n  selectionStart,\n  selectionEnd\n});\nconst onCompositionStart = () => console.log('compositionstart');\nconst onCompositionUpdate = ({\n  target: {\n    value,\n    selectionStart,\n    selectionEnd\n  },\n  data\n}) => console.log('compositionupdate', {\n  data,\n  value,\n  selectionStart,\n  selectionEnd\n});\nconst onCompositionEnd = () => console.log('compositionend');\nconst events = {\n  input: onInput,\n  compositionstart: onCompositionStart,\n  compositionupdate: onCompositionUpdate,\n  compositionend: onCompositionEnd\n};\nconst addDebugListeners = input => {\n  Object.entries(events).forEach(([event, handler]) => input.addEventListener(event, handler));\n};\nconst removeDebugListeners = input => {\n  Object.entries(events).forEach(([event, handler]) => input.removeEventListener(event, handler));\n};\nconst ELEMENTS = ['TEXTAREA', 'INPUT'];\nlet idCounter = 0;\nconst newId = () => {\n  idCounter += 1;\n  return `${Date.now()}${idCounter}`;\n};\n/**\n * Binds eventListener for 'input' events to an input field to automagically replace values with kana\n * Can pass `{ IMEMode: 'toHiragana' || 'toKatakana' }` to enforce kana conversion type\n * @param  {HTMLInputElement | HTMLTextAreaElement} element textarea, input[type=\"text\"] etc\n * @param  {DefaultOptions} [options=defaultOptions] defaults to { IMEMode: true } using `toKana`\n * @example\n * bind(document.querySelector('#myInput'));\n */\nfunction bind(element = {}, options = {}, debug = false) {\n  if (!ELEMENTS.includes(element.nodeName)) {\n    throw new Error(`Element provided to Wanakana bind() was not a valid input or textarea element.\\n Received: (${JSON.stringify(element)})`);\n  }\n  if (element.hasAttribute('data-wanakana-id')) {\n    return;\n  }\n  const onInput = makeOnInput(options);\n  const id = newId();\n  const attributes = [{\n    name: 'data-wanakana-id',\n    value: id\n  }, {\n    name: 'lang',\n    value: 'ja'\n  }, {\n    name: 'autoCapitalize',\n    value: 'none'\n  }, {\n    name: 'autoCorrect',\n    value: 'off'\n  }, {\n    name: 'autoComplete',\n    value: 'off'\n  }, {\n    name: 'spellCheck',\n    value: 'false'\n  }];\n  const previousAttributes = {};\n  attributes.forEach(attribute => {\n    previousAttributes[attribute.name] = element.getAttribute(attribute.name);\n    element.setAttribute(attribute.name, attribute.value);\n  });\n  element.dataset.previousAttributes = JSON.stringify(previousAttributes);\n  element.addEventListener('input', onInput);\n  element.addEventListener('compositionupdate', onComposition);\n  element.addEventListener('compositionend', onComposition);\n  trackListeners(id, onInput, onComposition);\n  if (debug === true) {\n    addDebugListeners(element);\n  }\n}\n\n/**\n * Unbinds eventListener from input field\n * @param  {HTMLInputElement | HTMLTextAreaElement} element textarea, input\n */\nfunction unbind(element, debug = false) {\n  const listeners = findListeners(element);\n  if (listeners == null) {\n    throw new Error(`Element provided to Wanakana unbind() had no listener registered.\\n Received: ${JSON.stringify(element)}`);\n  }\n  const {\n    inputHandler,\n    compositionHandler\n  } = listeners;\n  const attributes = JSON.parse(element.dataset.previousAttributes);\n  Object.keys(attributes).forEach(key => {\n    if (attributes[key]) {\n      element.setAttribute(key, attributes[key]);\n    } else {\n      element.removeAttribute(key);\n    }\n  });\n  element.removeAttribute('data-previous-attributes');\n  element.removeAttribute('data-ignore-composition');\n  element.removeEventListener('input', inputHandler);\n  element.removeEventListener('compositionstart', compositionHandler);\n  element.removeEventListener('compositionupdate', compositionHandler);\n  element.removeEventListener('compositionend', compositionHandler);\n  untrackListeners(listeners);\n  if (debug === true) {\n    removeDebugListeners(element);\n  }\n}\n\n/**\n * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharRomaji(char = '') {\n  if (isEmpty(char)) return false;\n  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\n/**\n * Test if `input` is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} [input=''] text\n * @param  {RegExp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if [Romaji](https://en.wikipedia.org/wiki/Romaji)\n * @example\n * isRomaji('Tōkyō and Ōsaka')\n * // => true\n * isRomaji('12a*b&c-d')\n * // => true\n * isRomaji('あアA')\n * // => false\n * isRomaji('お願い')\n * // => false\n * isRomaji('a！b&cーd') // Zenkaku punctuation fails\n * // => false\n * isRomaji('a！b&cーd', /[！ー]/)\n * // => true\n */\nfunction isRomaji(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input) ? false : [...input].every(char => {\n    const isRoma = isCharRomaji(char);\n    return !augmented ? isRoma : isRoma || allowed.test(char);\n  });\n}\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKatakana(char = '') {\n  return isCharInRange(char, KATAKANA_START, KATAKANA_END);\n}\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKana(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharHiragana(char) || isCharKatakana(char);\n}\n\n/**\n * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)\n * @example\n * isKana('あ')\n * // => true\n * isKana('ア')\n * // => true\n * isKana('あーア')\n * // => true\n * isKana('A')\n * // => false\n * isKana('あAア')\n * // => false\n */\nfunction isKana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKana);\n}\n\n/**\n * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @example\n * isHiragana('げーむ')\n * // => true\n * isHiragana('A')\n * // => false\n * isHiragana('あア')\n * // => false\n */\nfunction isHiragana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharHiragana);\n}\n\n/**\n * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @example\n * isKatakana('ゲーム')\n * // => true\n * isKatakana('あ')\n * // => false\n * isKatakana('A')\n * // => false\n * isKatakana('あア')\n * // => false\n */\nfunction isKatakana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKatakana);\n}\n\n/**\n * Returns true if char is '々'\n * @param  {String} char to test\n * @return {Boolean}\n */\nfunction isCharIterationMark(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === KANJI_ITERATION_MARK;\n}\n\n/**\n * Tests a character. Returns true if the character is a CJK ideograph (kanji).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKanji(char = '') {\n  return isCharInRange(char, KANJI_START, KANJI_END) || isCharIterationMark(char);\n}\n\n/**\n * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @example\n * isKanji('刀')\n * // => true\n * isKanji('切腹')\n * // => true\n * isKanji('勢い')\n * // => false\n * isKanji('あAア')\n * // => false\n * isKanji('🐸')\n * // => false\n */\nfunction isKanji(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKanji);\n}\n\n/**\n * Test if `input` contains a mix of [Romaji](https://en.wikipedia.org/wiki/Romaji) *and* [Kana](https://en.wikipedia.org/wiki/Kana), defaults to pass through [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @param  {String} input text\n * @param  {{ passKanji: Boolean}} [options={ passKanji: true }] optional config to pass through kanji\n * @return {Boolean} true if mixed\n * @example\n * isMixed('Abあア'))\n * // => true\n * isMixed('お腹A')) // ignores kanji by default\n * // => true\n * isMixed('お腹A', { passKanji: false }))\n * // => false\n * isMixed('ab'))\n * // => false\n * isMixed('あア'))\n * // => false\n */\nfunction isMixed(input = '', options = {\n  passKanji: true\n}) {\n  const chars = [...input];\n  let hasKanji = false;\n  if (!options.passKanji) {\n    hasKanji = chars.some(isKanji);\n  }\n  return (chars.some(isHiragana) || chars.some(isKatakana)) && chars.some(isRomaji) && !hasKanji;\n}\nconst isCharInitialLongDash = (char, index) => isCharLongDash(char) && index < 1;\nconst isCharInnerLongDash = (char, index) => isCharLongDash(char) && index > 0;\nconst isKanaAsSymbol = char => ['ヶ', 'ヵ'].includes(char);\nconst LONG_VOWELS = {\n  a: 'あ',\n  i: 'い',\n  u: 'う',\n  e: 'え',\n  o: 'う'\n};\n// inject toRomaji to avoid circular dependency between toRomaji <-> katakanaToHiragana\nfunction katakanaToHiragana(input = '', toRomaji, {\n  isDestinationRomaji,\n  convertLongVowelMark\n} = {}) {\n  let previousKana = '';\n  return input.split('').reduce((hira, char, index) => {\n    // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n    if (isCharSlashDot(char) || isCharInitialLongDash(char, index) || isKanaAsSymbol(char)) {\n      return hira.concat(char);\n    }\n    // Transform long vowels: 'オー' to 'おう'\n    if (convertLongVowelMark && previousKana && isCharInnerLongDash(char, index)) {\n      // Transform previousKana back to romaji, and slice off the vowel\n      const romaji = toRomaji(previousKana).slice(-1);\n      // However, ensure 'オー' => 'おお' => 'oo' if this is a transform on the way to romaji\n      if (isCharKatakana(input[index - 1]) && romaji === 'o' && isDestinationRomaji) {\n        return hira.concat('お');\n      }\n      return hira.concat(LONG_VOWELS[romaji]);\n      // Transform all other chars\n    }\n    if (!isCharLongDash(char) && isCharKatakana(char)) {\n      const code = char.charCodeAt(0) + (HIRAGANA_START - KATAKANA_START);\n      const hiraChar = String.fromCharCode(code);\n      previousKana = hiraChar;\n      return hira.concat(hiraChar);\n    }\n    // Pass non katakana chars through\n    previousKana = '';\n    return hira.concat(char);\n  }, []).join('');\n}\nlet kanaToHepburnMap = null;\n/* eslint-disable */\n// prettier-ignore\nconst BASIC_ROMAJI = {\n  あ: 'a',\n  い: 'i',\n  う: 'u',\n  え: 'e',\n  お: 'o',\n  か: 'ka',\n  き: 'ki',\n  く: 'ku',\n  け: 'ke',\n  こ: 'ko',\n  さ: 'sa',\n  し: 'shi',\n  す: 'su',\n  せ: 'se',\n  そ: 'so',\n  た: 'ta',\n  ち: 'chi',\n  つ: 'tsu',\n  て: 'te',\n  と: 'to',\n  な: 'na',\n  に: 'ni',\n  ぬ: 'nu',\n  ね: 'ne',\n  の: 'no',\n  は: 'ha',\n  ひ: 'hi',\n  ふ: 'fu',\n  へ: 'he',\n  ほ: 'ho',\n  ま: 'ma',\n  み: 'mi',\n  む: 'mu',\n  め: 'me',\n  も: 'mo',\n  ら: 'ra',\n  り: 'ri',\n  る: 'ru',\n  れ: 're',\n  ろ: 'ro',\n  や: 'ya',\n  ゆ: 'yu',\n  よ: 'yo',\n  わ: 'wa',\n  ゐ: 'wi',\n  ゑ: 'we',\n  を: 'wo',\n  ん: 'n',\n  が: 'ga',\n  ぎ: 'gi',\n  ぐ: 'gu',\n  げ: 'ge',\n  ご: 'go',\n  ざ: 'za',\n  じ: 'ji',\n  ず: 'zu',\n  ぜ: 'ze',\n  ぞ: 'zo',\n  だ: 'da',\n  ぢ: 'ji',\n  づ: 'zu',\n  で: 'de',\n  ど: 'do',\n  ば: 'ba',\n  び: 'bi',\n  ぶ: 'bu',\n  べ: 'be',\n  ぼ: 'bo',\n  ぱ: 'pa',\n  ぴ: 'pi',\n  ぷ: 'pu',\n  ぺ: 'pe',\n  ぽ: 'po',\n  ゔぁ: 'va',\n  ゔぃ: 'vi',\n  ゔ: 'vu',\n  ゔぇ: 've',\n  ゔぉ: 'vo'\n};\n/* eslint-enable  */\nconst SPECIAL_SYMBOLS = {\n  '。': '.',\n  '、': ',',\n  '：': ':',\n  '・': '/',\n  '！': '!',\n  '？': '?',\n  '〜': '~',\n  'ー': '-',\n  '「': '‘',\n  '」': '’',\n  '『': '“',\n  '』': '”',\n  '［': '[',\n  '］': ']',\n  '（': '(',\n  '）': ')',\n  '｛': '{',\n  '｝': '}',\n  '　': ' '\n};\n// んい -> n'i\nconst AMBIGUOUS_VOWELS = ['あ', 'い', 'う', 'え', 'お', 'や', 'ゆ', 'よ'];\nconst SMALL_Y = {\n  ゃ: 'ya',\n  ゅ: 'yu',\n  ょ: 'yo'\n};\nconst SMALL_Y_EXTRA = {\n  ぃ: 'yi',\n  ぇ: 'ye'\n};\nconst SMALL_AIUEO = {\n  ぁ: 'a',\n  ぃ: 'i',\n  ぅ: 'u',\n  ぇ: 'e',\n  ぉ: 'o'\n};\nconst YOON_KANA = ['き', 'に', 'ひ', 'み', 'り', 'ぎ', 'び', 'ぴ', 'ゔ', 'く', 'ふ'];\nconst YOON_EXCEPTIONS = {\n  し: 'sh',\n  ち: 'ch',\n  じ: 'j',\n  ぢ: 'j'\n};\nconst SMALL_KANA = {\n  っ: '',\n  ゃ: 'ya',\n  ゅ: 'yu',\n  ょ: 'yo',\n  ぁ: 'a',\n  ぃ: 'i',\n  ぅ: 'u',\n  ぇ: 'e',\n  ぉ: 'o'\n};\n// going with the intuitive (yet incorrect) solution where っや -> yya and っぃ -> ii\n// in other words, just assume the sokuon could have been applied to anything\nconst SOKUON_WHITELIST = {\n  b: 'b',\n  c: 't',\n  d: 'd',\n  f: 'f',\n  g: 'g',\n  h: 'h',\n  j: 'j',\n  k: 'k',\n  m: 'm',\n  p: 'p',\n  q: 'q',\n  r: 'r',\n  s: 's',\n  t: 't',\n  v: 'v',\n  w: 'w',\n  x: 'x',\n  z: 'z'\n};\nfunction getKanaToHepburnTree() {\n  if (kanaToHepburnMap == null) {\n    kanaToHepburnMap = createKanaToHepburnMap();\n  }\n  return kanaToHepburnMap;\n}\nfunction getKanaToRomajiTree(romanization) {\n  switch (romanization) {\n    case ROMANIZATIONS.HEPBURN:\n      return getKanaToHepburnTree();\n    default:\n      return {};\n  }\n}\nfunction createKanaToHepburnMap() {\n  const romajiTree = transform(BASIC_ROMAJI);\n  const subtreeOf = string => getSubTreeOf(romajiTree, string);\n  const setTrans = (string, transliteration) => {\n    subtreeOf(string)[''] = transliteration;\n  };\n  Object.entries(SPECIAL_SYMBOLS).forEach(([jsymbol, symbol]) => {\n    subtreeOf(jsymbol)[''] = symbol;\n  });\n  [...Object.entries(SMALL_Y), ...Object.entries(SMALL_AIUEO)].forEach(([roma, kana]) => {\n    setTrans(roma, kana);\n  });\n  // きゃ -> kya\n  YOON_KANA.forEach(kana => {\n    const firstRomajiChar = subtreeOf(kana)[''][0];\n    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, firstRomajiChar + yRoma);\n    });\n    // きぃ -> kyi\n    Object.entries(SMALL_Y_EXTRA).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, firstRomajiChar + yRoma);\n    });\n  });\n  Object.entries(YOON_EXCEPTIONS).forEach(([kana, roma]) => {\n    // じゃ -> ja\n    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, roma + yRoma[1]);\n    });\n    // じぃ -> jyi, じぇ -> je\n    setTrans(`${kana}ぃ`, `${roma}yi`);\n    setTrans(`${kana}ぇ`, `${roma}e`);\n  });\n  romajiTree['っ'] = resolveTsu(romajiTree);\n  Object.entries(SMALL_KANA).forEach(([kana, roma]) => {\n    setTrans(kana, roma);\n  });\n  AMBIGUOUS_VOWELS.forEach(kana => {\n    setTrans(`ん${kana}`, `n'${subtreeOf(kana)['']}`);\n  });\n  // NOTE: could be re-enabled with an option?\n  // // んば -> mbo\n  // const LABIAL = [\n  //   'ば', 'び', 'ぶ', 'べ', 'ぼ',\n  //   'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ',\n  //   'ま', 'み', 'む', 'め', 'も',\n  // ];\n  // LABIAL.forEach((kana) => {\n  //   setTrans(`ん${kana}`, `m${subtreeOf(kana)['']}`);\n  // });\n  return Object.freeze(JSON.parse(JSON.stringify(romajiTree)));\n}\nfunction resolveTsu(tree) {\n  return Object.entries(tree).reduce((tsuTree, [key, value]) => {\n    if (!key) {\n      // we have reached the bottom of this branch\n      const consonant = value.charAt(0);\n      // eslint-disable-next-line no-param-reassign\n      tsuTree[key] = Object.keys(SOKUON_WHITELIST).includes(consonant) ? SOKUON_WHITELIST[consonant] + value : value;\n    } else {\n      // more subtrees\n      // eslint-disable-next-line no-param-reassign\n      tsuTree[key] = resolveTsu(value);\n    }\n    return tsuTree;\n  }, {});\n}\n\n// memoize and deeply compare args so we only recreate when necessary\nconst createKanaToRomajiMap = memoizeOne((romanization, customRomajiMapping) => {\n  let map = getKanaToRomajiTree(romanization);\n  if (customRomajiMapping) {\n    map = mergeCustomMapping(map, customRomajiMapping);\n  }\n  return map;\n}, dequal);\n/**\n * Convert kana to romaji\n * @param  {String} kana text input\n * @param  {DefaultOptions} [options=defaultOptions]\n * @param  {Object.<string, string>} [map] custom mapping\n * @return {String} converted text\n * @example\n * toRomaji('ひらがな　カタカナ')\n * // => 'hiragana katakana'\n * toRomaji('げーむ　ゲーム')\n * // => 'ge-mu geemu'\n * toRomaji('ひらがな　カタカナ', { upcaseKatakana: true })\n * // => 'hiragana KATAKANA'\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' } });\n * // => 'tuzigili'\n */\nfunction toRomaji(input = '', options = {}, map) {\n  const config = mergeWithDefaultOptions(options);\n  if (!map) {\n    map = createKanaToRomajiMap(config.romanization, config.customRomajiMapping);\n  }\n  // just throw away the substring index information and simply concatenate all the kana\n  return splitIntoRomaji(input, config, map).map(romajiToken => {\n    const [start, end, romaji] = romajiToken;\n    const makeUpperCase = config.upcaseKatakana && isKatakana(input.slice(start, end));\n    return makeUpperCase ? romaji.toUpperCase() : romaji;\n  }).join('');\n}\nfunction splitIntoRomaji(input, options, map) {\n  if (!map) {\n    map = createKanaToRomajiMap(options.romanization, options.customRomajiMapping);\n  }\n  const config = Object.assign({}, {\n    isDestinationRomaji: true\n  }, options);\n  return applyMapping(katakanaToHiragana(input, toRomaji, config), map, !options.IMEMode);\n}\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharEnglishPunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\n/**\n * Convert input to [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toHiragana('toukyou, オオサカ')\n * // => 'とうきょう、　おおさか'\n * toHiragana('only カナ', { passRomaji: true })\n * // => 'only かな'\n * toHiragana('wi')\n * // => 'うぃ'\n * toHiragana('wi', { useObsoleteKana: true })\n * // => 'ゐ'\n */\nfunction toHiragana(input = '', options = {}) {\n  const config = mergeWithDefaultOptions(options);\n  if (config.passRomaji) {\n    return katakanaToHiragana(input, toRomaji, config);\n  }\n  if (isMixed(input, {\n    passKanji: true\n  })) {\n    const convertedKatakana = katakanaToHiragana(input, toRomaji, config);\n    return toKana(convertedKatakana.toLowerCase(), config);\n  }\n  if (isRomaji(input) || isCharEnglishPunctuation(input)) {\n    return toKana(input.toLowerCase(), config);\n  }\n  return katakanaToHiragana(input, toRomaji, config);\n}\n\n/**\n * Convert input to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toKatakana('toukyou, おおさか')\n * // => 'トウキョウ、　オオサカ'\n * toKatakana('only かな', { passRomaji: true })\n * // => 'only カナ'\n * toKatakana('wi')\n * // => 'ウィ'\n * toKatakana('wi', { useObsoleteKana: true })\n * // => 'ヰ'\n */\nfunction toKatakana(input = '', options = {}) {\n  const mergedOptions = mergeWithDefaultOptions(options);\n  if (mergedOptions.passRomaji) {\n    return hiraganaToKatakana(input);\n  }\n  if (isMixed(input) || isRomaji(input) || isCharEnglishPunctuation(input)) {\n    const hiragana = toKana(input.toLowerCase(), mergedOptions);\n    return hiraganaToKatakana(hiragana);\n  }\n  return hiraganaToKatakana(input);\n}\n\n/**\n * Tests a character. Returns true if the character is considered Japanese punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanesePunctuation(char = '') {\n  if (isEmpty(char) || isCharIterationMark(char)) return false;\n  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\nconst isCharEnSpace = x => x === ' ';\nconst isCharJaSpace = x => x === '　';\nconst isCharJaNum = x => /[０-９]/.test(x);\nconst isCharEnNum = x => /[0-9]/.test(x);\nconst TOKEN_TYPES = {\n  EN: 'en',\n  JA: 'ja',\n  EN_NUM: 'englishNumeral',\n  JA_NUM: 'japaneseNumeral',\n  EN_PUNC: 'englishPunctuation',\n  JA_PUNC: 'japanesePunctuation',\n  KANJI: 'kanji',\n  HIRAGANA: 'hiragana',\n  KATAKANA: 'katakana',\n  SPACE: 'space',\n  OTHER: 'other'\n};\n// prettier-ignore\nfunction getType(input, compact = false) {\n  const {\n    EN,\n    JA,\n    EN_NUM,\n    JA_NUM,\n    EN_PUNC,\n    JA_PUNC,\n    KANJI,\n    HIRAGANA,\n    KATAKANA,\n    SPACE,\n    OTHER\n  } = TOKEN_TYPES;\n  if (compact) {\n    switch (true) {\n      case isCharJaNum(input):\n        return OTHER;\n      case isCharEnNum(input):\n        return OTHER;\n      case isCharEnSpace(input):\n        return EN;\n      case isCharEnglishPunctuation(input):\n        return OTHER;\n      case isCharJaSpace(input):\n        return JA;\n      case isCharJapanesePunctuation(input):\n        return OTHER;\n      case isCharJapanese(input):\n        return JA;\n      case isCharRomaji(input):\n        return EN;\n      default:\n        return OTHER;\n    }\n  } else {\n    switch (true) {\n      case isCharJaSpace(input):\n        return SPACE;\n      case isCharEnSpace(input):\n        return SPACE;\n      case isCharJaNum(input):\n        return JA_NUM;\n      case isCharEnNum(input):\n        return EN_NUM;\n      case isCharEnglishPunctuation(input):\n        return EN_PUNC;\n      case isCharJapanesePunctuation(input):\n        return JA_PUNC;\n      case isCharKanji(input):\n        return KANJI;\n      case isCharHiragana(input):\n        return HIRAGANA;\n      case isCharKatakana(input):\n        return KATAKANA;\n      case isCharJapanese(input):\n        return JA;\n      case isCharRomaji(input):\n        return EN;\n      default:\n        return OTHER;\n    }\n  }\n}\n/**\n * Splits input into array of strings separated by opinionated token types\n * `'en', 'ja', 'englishNumeral', 'japaneseNumeral','englishPunctuation', 'japanesePunctuation','kanji', 'hiragana', 'katakana', 'space', 'other'`.\n * If `{ compact: true }` then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation).\n * If `{ detailed: true }` then return array will contain `{ type, value }` instead of `'value'`\n * @param  {String} input text\n * @param  {{compact: Boolean | undefined, detailed: Boolean | undefined}} [options={ compact: false, detailed: false}] options to modify output style\n * @return {(String[]|Array.<{type: String, value: String}>)} text split into tokens containing values, or detailed object\n * @example\n * tokenize('ふふフフ')\n * // ['ふふ', 'フフ']\n *\n * tokenize('感じ')\n * // ['感', 'じ']\n *\n * tokenize('人々')\n * // ['人々']\n *\n * tokenize('truly 私は悲しい')\n * // ['truly', ' ', '私', 'は', '悲', 'しい']\n *\n * tokenize('truly 私は悲しい', { compact: true })\n * // ['truly ', '私は悲しい']\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！')\n * // [ '5', 'romaji', ' ', 'here', '...!?', '人々漢字', 'ひらがな', 'カタ', '　', 'カナ', '４', '「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！', { compact: true })\n * // [ '5', 'romaji here', '...!?', '人々漢字ひらがなカタ　カナ', '４「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { detailed: true })\n * // [\n *  { type: 'englishNumeral', value: '5' },\n *  { type: 'en', value: 'romaji' },\n *  { type: 'space', value: ' ' },\n *  { type: 'en', value: 'here' },\n *  { type: 'englishPunctuation', value: '...!?' },\n *  { type: 'kanji', value: '人々漢字' },\n *  { type: 'hiragana', value: 'ひらがな' },\n *  { type: 'katakana', value: 'カタ' },\n *  { type: 'space', value: '　' },\n *  { type: 'katakana', value: 'カナ' },\n *  { type: 'japaneseNumeral', value: '４' },\n *  { type: 'japanesePunctuation', value: '「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'japanesePunctuation', value: '」。！' },\n *  { type: 'space', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n * ]\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { compact: true, detailed: true})\n * // [\n *  { type: 'other', value: '5' },\n *  { type: 'en', value: 'romaji here' },\n *  { type: 'other', value: '...!?' },\n *  { type: 'ja', value: '人々漢字ひらがなカタ　カナ' },\n *  { type: 'other', value: '４「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'other', value: '」。！' },\n *  { type: 'en', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n *]\n */\nfunction tokenize(input, {\n  compact = false,\n  detailed = false\n} = {}) {\n  if (input == null || isEmpty(input)) {\n    return [];\n  }\n  const chars = [...input];\n  let initial = chars.shift();\n  let prevType = getType(initial, compact);\n  initial = detailed ? {\n    type: prevType,\n    value: initial\n  } : initial;\n  const result = chars.reduce((tokens, char) => {\n    const currType = getType(char, compact);\n    const sameType = currType === prevType;\n    prevType = currType;\n    let newValue = char;\n    if (sameType) {\n      newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;\n    }\n    return detailed ? tokens.concat({\n      type: currType,\n      value: newValue\n    }) : tokens.concat(newValue);\n  }, [initial]);\n  return result;\n}\nconst isLeadingWithoutInitialKana = (input, leading) => leading && !isKana(input[0]);\nconst isTrailingWithoutFinalKana = (input, leading) => !leading && !isKana(input[input.length - 1]);\nconst isInvalidMatcher = (input, matchKanji) => matchKanji && ![...matchKanji].some(isKanji) || !matchKanji && isKana(input);\n/**\n * Strips [Okurigana](https://en.wikipedia.org/wiki/Okurigana)\n * @param  {String} input text\n * @param  {{ leading: Boolean | undefined, matchKanji: string | undefined }} [options={ leading: false, matchKanji: '' }] optional config\n * @return {String} text with okurigana removed\n * @example\n * stripOkurigana('踏み込む')\n * // => '踏み込'\n * stripOkurigana('お祝い')\n * // => 'お祝'\n * stripOkurigana('お腹', { leading: true });\n * // => '腹'\n * stripOkurigana('ふみこむ', { matchKanji: '踏み込む' });\n * // => 'ふみこ'\n * stripOkurigana('おみまい', { matchKanji: 'お祝い', leading: true });\n * // => 'みまい'\n */\nfunction stripOkurigana(input = '', {\n  leading = false,\n  matchKanji = ''\n} = {}) {\n  if (!isJapanese(input) || isLeadingWithoutInitialKana(input, leading) || isTrailingWithoutFinalKana(input, leading) || isInvalidMatcher(input, matchKanji)) {\n    return input;\n  }\n  const chars = matchKanji || input;\n  const okuriganaRegex = new RegExp(leading ? `^${tokenize(chars).shift()}` : `${tokenize(chars).pop()}$`);\n  return input.replace(okuriganaRegex, '');\n}\nexport { ROMANIZATIONS, TO_KANA_METHODS, VERSION, bind, isHiragana, isJapanese, isKana, isKanji, isKatakana, isMixed, isRomaji, stripOkurigana, toHiragana, toKana, toKatakana, toRomaji, tokenize, unbind };","map":{"version":3,"names":["typeOf","value","Object","toString","call","slice","toLowerCase","isEmpty","input","length","isCharInRange","char","start","end","code","charCodeAt","VERSION","TO_KANA_METHODS","HIRAGANA","KATAKANA","ROMANIZATIONS","HEPBURN","DEFAULT_OPTIONS","useObsoleteKana","passRomaji","convertLongVowelMark","upcaseKatakana","IMEMode","romanization","LATIN_UPPERCASE_START","LATIN_UPPERCASE_END","LOWERCASE_ZENKAKU_START","LOWERCASE_ZENKAKU_END","UPPERCASE_ZENKAKU_START","UPPERCASE_ZENKAKU_END","HIRAGANA_START","HIRAGANA_END","KATAKANA_START","KATAKANA_END","KANJI_START","KANJI_END","KANJI_ITERATION_MARK","PROLONGED_SOUND_MARK","KANA_SLASH_DOT","ZENKAKU_NUMBERS","ZENKAKU_UPPERCASE","ZENKAKU_LOWERCASE","ZENKAKU_PUNCTUATION_1","ZENKAKU_PUNCTUATION_2","ZENKAKU_PUNCTUATION_3","ZENKAKU_PUNCTUATION_4","ZENKAKU_SYMBOLS_CURRENCY","HIRAGANA_CHARS","KATAKANA_CHARS","HANKAKU_KATAKANA","KATAKANA_PUNCTUATION","KANA_PUNCTUATION","CJK_SYMBOLS_PUNCTUATION","COMMON_CJK","RARE_CJK","KANA_RANGES","JA_PUNCTUATION_RANGES","JAPANESE_RANGES","MODERN_ENGLISH","HEPBURN_MACRON_RANGES","SMART_QUOTE_RANGES","ROMAJI_RANGES","EN_PUNCTUATION_RANGES","isCharJapanese","some","isJapanese","allowed","augmented","every","isJa","test","safeIsNaN","Number","isNaN","ponyfill","isEqual","first","second","areInputsEqual","newInputs","lastInputs","i","memoizeOne","resultFn","cache","memoized","newArgs","_i","arguments","lastThis","lastArgs","lastResult","apply","clear","has","prototype","hasOwnProperty","find","iter","tar","key","keys","dequal","foo","bar","ctor","len","tmp","constructor","Date","getTime","RegExp","Array","Set","size","Map","get","ArrayBuffer","Uint8Array","DataView","byteLength","getInt8","isView","mergeWithDefaultOptions","opts","assign","applyMapping","string","mapping","convertEnding","root","nextSubtree","tree","nextChar","subtree","undefined","newChunk","remaining","currentCursor","firstChar","charAt","parse","lastCursor","concat","transform","entries","reduce","map","endOfBranch","getSubTreeOf","split","correctSubTree","createCustomMapping","customMap","customTree","forEach","roma","kana","subTree","makeMap","mapCopy","JSON","stringify","transformMap","mapSubtree","customSubtree","newSubtree","mergeCustomMapping","customMapping","BASIC_KUNREI","a","u","e","o","k","s","t","n","h","m","y","r","w","g","z","d","b","p","v","SPECIAL_SYMBOLS$1","CONSONANTS","q","f","SMALL_Y$1","ya","yi","yu","ye","yo","SMALL_VOWELS","ALIASES","sh","ch","cy","chy","shy","j","jy","shi","chi","tsu","ji","fu","SMALL_LETTERS","tu","wa","ka","ke","SPECIAL_CASES","wu","wi","we","kwa","whu","tha","thu","tho","dha","dhu","dho","AIUEO_CONSTRUCTIONS","wh","kw","qw","gw","sw","ts","th","tw","dh","dw","fw","createRomajiToKanaMap$1","createRomajiToKanaMap","kanaTree","subtreeOf","consonant","yKana","symbol","jsymbol","aiueoKana","vowel","nChar","c","alternative","allExceptLast","last","parentTree","getAlternatives","list","alt","startsWith","replace","kunreiRoma","chars","xRoma","xSubtree","altRoma","prefix","altParentTree","addTsu","tsuTree","freeze","romajiToKanaMap","getRomajiToKanaTree","USE_OBSOLETE_KANA_MAP","IME_MODE_MAP","isCharUpperCase","isCharLongDash","isCharSlashDot","isCharHiragana","hiraganaToKatakana","kata","push","kataChar","String","fromCharCode","join","customKanaMapping","toKana","options","config","splitIntoConvertedKana","kanaToken","enforceHiragana","enforceKatakana","LISTENERS","makeOnInput","prevInput","mergedConfig","preConfiguredMap","triggers","toUpperCase","onInput","target","dataset","ignoreComposition","convertInput","head","textToConvert","tail","splitInput","selectionEnd","convertedText","changed","newCursor","newValue","setTimeout","setSelectionRange","onComposition","type","data","isMacOS","window","navigator","platform","trackListeners","id","inputHandler","compositionHandler","untrackListeners","targetId","filter","findListeners","el","getAttribute","text","cursor","toConvert","includes","workFromStart","workBackwards","takeWhileAndSlice","catalystChars","startIndex","reverse","source","predicate","x","result","selectionStart","console","log","onCompositionStart","onCompositionUpdate","onCompositionEnd","events","compositionstart","compositionupdate","compositionend","addDebugListeners","event","handler","addEventListener","removeDebugListeners","removeEventListener","ELEMENTS","idCounter","newId","now","bind","element","debug","nodeName","Error","hasAttribute","attributes","name","previousAttributes","attribute","setAttribute","unbind","listeners","removeAttribute","isCharRomaji","isRomaji","isRoma","isCharKatakana","isCharKana","isKana","isHiragana","isKatakana","isCharIterationMark","isCharKanji","isKanji","isMixed","passKanji","hasKanji","isCharInitialLongDash","index","isCharInnerLongDash","isKanaAsSymbol","LONG_VOWELS","katakanaToHiragana","toRomaji","isDestinationRomaji","previousKana","hira","romaji","hiraChar","kanaToHepburnMap","BASIC_ROMAJI","あ","い","う","え","お","か","き","く","け","こ","さ","し","す","せ","そ","た","ち","つ","て","と","な","に","ぬ","ね","の","は","ひ","ふ","へ","ほ","ま","み","む","め","も","ら","り","る","れ","ろ","や","ゆ","よ","わ","ゐ","ゑ","を","ん","が","ぎ","ぐ","げ","ご","ざ","じ","ず","ぜ","ぞ","だ","ぢ","づ","で","ど","ば","び","ぶ","べ","ぼ","ぱ","ぴ","ぷ","ぺ","ぽ","ゔぁ","ゔぃ","ゔ","ゔぇ","ゔぉ","SPECIAL_SYMBOLS","AMBIGUOUS_VOWELS","SMALL_Y","ゃ","ゅ","ょ","SMALL_Y_EXTRA","ぃ","ぇ","SMALL_AIUEO","ぁ","ぅ","ぉ","YOON_KANA","YOON_EXCEPTIONS","SMALL_KANA","っ","SOKUON_WHITELIST","getKanaToHepburnTree","createKanaToHepburnMap","getKanaToRomajiTree","romajiTree","setTrans","transliteration","firstRomajiChar","yRoma","resolveTsu","createKanaToRomajiMap","customRomajiMapping","splitIntoRomaji","romajiToken","makeUpperCase","isCharEnglishPunctuation","toHiragana","convertedKatakana","toKatakana","mergedOptions","hiragana","isCharJapanesePunctuation","isCharEnSpace","isCharJaSpace","isCharJaNum","isCharEnNum","TOKEN_TYPES","EN","JA","EN_NUM","JA_NUM","EN_PUNC","JA_PUNC","KANJI","SPACE","OTHER","getType","compact","tokenize","detailed","initial","shift","prevType","tokens","currType","sameType","pop","isLeadingWithoutInitialKana","leading","isTrailingWithoutFinalKana","isInvalidMatcher","matchKanji","stripOkurigana","okuriganaRegex"],"sources":["C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\typeOf.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isEmpty.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharInRange.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\constants.ts","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharJapanese.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\isJapanese.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\node_modules\\memoize-one\\dist\\memoize-one.esm.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\node_modules\\dequal\\dist\\index.mjs","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\mergeWithDefaultOptions.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\kanaMapping.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\romajiToKanaMap.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharUpperCase.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharLongDash.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharSlashDot.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharHiragana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\hiraganaToKatakana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\toKana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\dom.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\logInputEvents.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\bind.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\unbind.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharRomaji.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\isRomaji.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharKatakana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharKana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\isKana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\isHiragana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\isKatakana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharIterationMark.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharKanji.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\isKanji.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\isMixed.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\katakanaToHiragana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\kanaToRomajiMap.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\toRomaji.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharEnglishPunctuation.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\toHiragana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\toKatakana.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\utils\\isCharJapanesePunctuation.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\tokenize.js","C:\\Users\\brays\\Documents\\Projects\\JapaneseLanguageApp\\japanese-language-app\\frontend\\node_modules\\src\\stripOkurigana.js"],"sourcesContent":["/**\n * Returns detailed type as string (instead of just 'object' for arrays etc)\n * @private\n * @param {any} value js value\n * @returns {String} type of value\n * @example\n * typeOf({}); // 'object'\n * typeOf([]); // 'array'\n * typeOf(function() {}); // 'function'\n * typeOf(/a/); // 'regexp'\n * typeOf(new Date()); // 'date'\n * typeOf(null); // 'null'\n * typeOf(undefined); // 'undefined'\n * typeOf('a'); // 'string'\n * typeOf(1); // 'number'\n * typeOf(true); // 'boolean'\n * typeOf(new Map()); // 'map'\n * typeOf(new Set()); // 'map'\n */\nfunction typeOf(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value !== Object(value)) {\n    return typeof value;\n  }\n  return {}.toString\n    .call(value)\n    .slice(8, -1)\n    .toLowerCase();\n}\n\nexport default typeOf;\n","import typeOf from './typeOf';\n/**\n * Checks if input string is empty\n * @param  {String} input text input\n * @return {Boolean} true if no input\n */\nfunction isEmpty(input) {\n  if (typeOf(input) !== 'string') {\n    return true;\n  }\n  return !input.length;\n}\n\nexport default isEmpty;\n","import isEmpty from './isEmpty';\n\n/**\n * Takes a character and a unicode range. Returns true if the char is in the range.\n * @param  {String}  char  unicode character\n * @param  {Number}  start unicode start range\n * @param  {Number}  end   unicode end range\n * @return {Boolean}\n */\nfunction isCharInRange(char = '', start, end) {\n  if (isEmpty(char)) return false;\n  const code = char.charCodeAt(0);\n  return start <= code && code <= end;\n}\n\nexport default isCharInRange;\n","export const VERSION = '5.3.1';\n\nexport const TO_KANA_METHODS: {\n  HIRAGANA: 'toHiragana',\n  KATAKANA: 'toKatakana',\n} = {\n  HIRAGANA: 'toHiragana',\n  KATAKANA: 'toKatakana',\n};\n\nexport const ROMANIZATIONS: { HEPBURN: 'hepburn' } = {\n  HEPBURN: 'hepburn',\n};\n\nexport type DefaultOptions = {\n  useObsoleteKana?: boolean,\n  passRomaji?: boolean,\n  convertLongVowelMark?: boolean,\n  upcaseKatakana?: boolean,\n  IMEMode?: boolean | 'toHiragana' | 'toKatakana',\n  romanization?: 'hepburn',\n  customKanaMapping?: { [index: string]: string }\n  customRomajiMapping?: { [index: string]: string }\n};\n\n/**\n * Default config for WanaKana, user passed options will be merged with these\n * @type {DefaultOptions}\n * @name DefaultOptions\n * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ゐ and ゑ.\n * @example\n * toHiragana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()\n * @example\n * toHiragana('only convert the katakana: ヒラガナ', { passRomaji: true })\n * // => \"only convert the katakana: ひらがな\"\n * @property {Boolean} [convertLongVowelMark=true] - Set to false to prevent conversions of 'ー' to extended vowels with toHiragana()\n * @example\n * toHiragana('ラーメン', { convertLongVowelMark: false });\n * // => 'らーめん\n * @property {Boolean} [upcaseKatakana=false] - Set to true to convert katakana to uppercase using toRomaji()\n * @example\n * toRomaji('ひらがな カタカナ', { upcaseKatakana: true })\n * // => \"hiragana KATAKANA\"\n * @property {Boolean | 'toHiragana' | 'toKatakana'} [IMEMode=false] - Set to true, 'toHiragana', or 'toKatakana' to handle conversion while it is being typed.\n * @property {'hepburn'} [romanization='hepburn'] - choose toRomaji() romanization map (currently only 'hepburn')\n * @property {Object.<String, String>} [customKanaMapping] - custom map will be merged with default conversion\n * @example\n * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'Bana' }) };\n * // => 'わにBanaに'\n * @property {Object.<String, String>} [customRomajiMapping] - custom map will be merged with default conversion\n * @example\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' }) };\n * // => 'tuzigili'\n */\nexport const DEFAULT_OPTIONS: DefaultOptions = {\n  useObsoleteKana: false,\n  passRomaji: false,\n  convertLongVowelMark: true,\n  upcaseKatakana: false,\n  IMEMode: false,\n  romanization: ROMANIZATIONS.HEPBURN,\n};\n\n// CharCode References\n// http://www.rikai.com/library/kanjitables/kanji_codes.unicode.shtml\n// http://unicode-table.com\n\nexport const LATIN_LOWERCASE_START = 0x61;\nexport const LATIN_LOWERCASE_END = 0x7a;\nexport const LATIN_UPPERCASE_START = 0x41;\nexport const LATIN_UPPERCASE_END = 0x5a;\nexport const LOWERCASE_ZENKAKU_START = 0xff41;\nexport const LOWERCASE_ZENKAKU_END = 0xff5a;\nexport const UPPERCASE_ZENKAKU_START = 0xff21;\nexport const UPPERCASE_ZENKAKU_END = 0xff3a;\nexport const HIRAGANA_START = 0x3041;\nexport const HIRAGANA_END = 0x3096;\nexport const KATAKANA_START = 0x30a1;\nexport const KATAKANA_END = 0x30fc;\nexport const KANJI_START = 0x4e00;\nexport const KANJI_END = 0x9faf;\n\nexport const KANJI_ITERATION_MARK = 0x3005; // 々\nexport const PROLONGED_SOUND_MARK = 0x30fc; // ー\nexport const KANA_SLASH_DOT = 0x30fb; // ・\n\nconst ZENKAKU_NUMBERS = [0xff10, 0xff19];\nconst ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];\nconst ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];\nconst ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];\nconst ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];\nconst ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];\nconst ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];\nconst ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];\n\nconst HIRAGANA_CHARS = [0x3040, 0x309f];\nconst KATAKANA_CHARS = [0x30a0, 0x30ff];\nconst HANKAKU_KATAKANA = [0xff66, 0xff9f];\nconst KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];\nconst KANA_PUNCTUATION = [0xff61, 0xff65];\nconst CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];\nconst COMMON_CJK = [0x4e00, 0x9fff];\nconst RARE_CJK = [0x3400, 0x4dbf];\n\nexport const KANA_RANGES = [\n  HIRAGANA_CHARS,\n  KATAKANA_CHARS,\n  KANA_PUNCTUATION,\n  HANKAKU_KATAKANA,\n];\n\nexport const JA_PUNCTUATION_RANGES = [\n  CJK_SYMBOLS_PUNCTUATION,\n  KANA_PUNCTUATION,\n  KATAKANA_PUNCTUATION,\n  ZENKAKU_PUNCTUATION_1,\n  ZENKAKU_PUNCTUATION_2,\n  ZENKAKU_PUNCTUATION_3,\n  ZENKAKU_PUNCTUATION_4,\n  ZENKAKU_SYMBOLS_CURRENCY,\n];\n\n// All Japanese unicode start and end ranges\n// Includes kanji, kana, zenkaku latin chars, punctuation, and number ranges.\nexport const JAPANESE_RANGES = [\n  ...KANA_RANGES,\n  ...JA_PUNCTUATION_RANGES,\n  ZENKAKU_UPPERCASE,\n  ZENKAKU_LOWERCASE,\n  ZENKAKU_NUMBERS,\n  COMMON_CJK,\n  RARE_CJK,\n];\n\nconst MODERN_ENGLISH = [0x0000, 0x007f];\nconst HEPBURN_MACRON_RANGES = [\n  [0x0100, 0x0101], // Ā ā\n  [0x0112, 0x0113], // Ē ē\n  [0x012a, 0x012b], // Ī ī\n  [0x014c, 0x014d], // Ō ō\n  [0x016a, 0x016b], // Ū ū\n];\nconst SMART_QUOTE_RANGES = [\n  [0x2018, 0x2019], // ‘ ’\n  [0x201c, 0x201d], // “ ”\n];\n\nexport const ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];\n\nexport const EN_PUNCTUATION_RANGES = [\n  [0x20, 0x2f],\n  [0x3a, 0x3f],\n  [0x5b, 0x60],\n  [0x7b, 0x7e],\n  ...SMART_QUOTE_RANGES,\n];\n","import isCharInRange from './isCharInRange';\nimport { JAPANESE_RANGES } from '../constants.ts';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanese(char = '') {\n  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanese;\n","import typeOf from './utils/typeOf';\nimport isEmpty from './utils/isEmpty';\nimport isCharJapanese from './utils/isCharJapanese';\n\n/**\n * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.”\n * @param  {String} [input=''] text\n * @param  {RegExp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if passes checks\n * @example\n * isJapanese('泣き虫')\n * // => true\n * isJapanese('あア')\n * // => true\n * isJapanese('２月') // Zenkaku numbers allowed\n * // => true\n * isJapanese('泣き虫。！〜＄') // Zenkaku/JA punctuation\n * // => true\n * isJapanese('泣き虫.!~$') // Latin punctuation fails\n * // => false\n * isJapanese('A泣き虫')\n * // => false\n * isJapanese('≪偽括弧≫', /[≪≫]/);\n * // => true\n */\nfunction isJapanese(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input)\n    ? false\n    : [...input].every((char) => {\n      const isJa = isCharJapanese(char);\n      return !augmented ? isJa : isJa || allowed.test(char);\n    });\n}\n\nexport default isJapanese;\n","var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var cache = null;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n            return cache.lastResult;\n        }\n        var lastResult = resultFn.apply(this, newArgs);\n        cache = {\n            lastResult: lastResult,\n            lastArgs: newArgs,\n            lastThis: this,\n        };\n        return lastResult;\n    }\n    memoized.clear = function clear() {\n        cache = null;\n    };\n    return memoized;\n}\n\nexport { memoizeOne as default };\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { DEFAULT_OPTIONS } from '../constants.ts';\n/**\n * Easy re-use of merging with default options\n * @param {Object} opts user options\n * @returns user options merged over default options\n */\nconst mergeWithDefaultOptions = (opts = {}) => Object.assign({}, DEFAULT_OPTIONS, opts);\n\nexport default mergeWithDefaultOptions;\n","import typeOf from './typeOf';\n\nexport function applyMapping(string, mapping, convertEnding) {\n  const root = mapping;\n\n  function nextSubtree(tree, nextChar) {\n    const subtree = tree[nextChar];\n    if (subtree === undefined) {\n      return undefined;\n    }\n    // if the next child node does not have a node value, set its node value to the input\n    return Object.assign({ '': tree[''] + nextChar }, tree[nextChar]);\n  }\n\n  function newChunk(remaining, currentCursor) {\n    // start parsing a new chunk\n    const firstChar = remaining.charAt(0);\n\n    return parse(\n      Object.assign({ '': firstChar }, root[firstChar]),\n      remaining.slice(1),\n      currentCursor,\n      currentCursor + 1\n    );\n  }\n\n  function parse(tree, remaining, lastCursor, currentCursor) {\n    if (!remaining) {\n      if (convertEnding || Object.keys(tree).length === 1) {\n        // nothing more to consume, just commit the last chunk and return it\n        // so as to not have an empty element at the end of the result\n        return tree[''] ? [[lastCursor, currentCursor, tree['']]] : [];\n      }\n      // if we don't want to convert the ending, because there are still possible continuations\n      // return null as the final node value\n      return [[lastCursor, currentCursor, null]];\n    }\n\n    if (Object.keys(tree).length === 1) {\n      return [[lastCursor, currentCursor, tree['']]].concat(\n        newChunk(remaining, currentCursor)\n      );\n    }\n\n    const subtree = nextSubtree(tree, remaining.charAt(0));\n\n    if (subtree === undefined) {\n      return [[lastCursor, currentCursor, tree['']]].concat(\n        newChunk(remaining, currentCursor)\n      );\n    }\n    // continue current branch\n    return parse(subtree, remaining.slice(1), lastCursor, currentCursor + 1);\n  }\n\n  return newChunk(string, 0);\n}\n\n// transform the tree, so that for example hepburnTree['ゔ']['ぁ'][''] === 'va'\n// or kanaTree['k']['y']['a'][''] === 'きゃ'\nexport function transform(tree) {\n  return Object.entries(tree).reduce((map, [char, subtree]) => {\n    const endOfBranch = typeOf(subtree) === 'string';\n    // eslint-disable-next-line no-param-reassign\n    map[char] = endOfBranch ? { '': subtree } : transform(subtree);\n    return map;\n  }, {});\n}\n\nexport function getSubTreeOf(tree, string) {\n  return string.split('').reduce((correctSubTree, char) => {\n    if (correctSubTree[char] === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      correctSubTree[char] = {};\n    }\n    return correctSubTree[char];\n  }, tree);\n}\n\n/**\n * Creates a custom mapping tree, returns a function that accepts a defaultMap which the newly created customMapping will be merged with and returned\n * (customMap) => (defaultMap) => mergedMap\n * @param  {Object} customMap { 'ka' : 'な' }\n * @return {Function} (defaultMap) => defaultMergedWithCustomMap\n * @example\n * const sillyMap = createCustomMapping({ 'ちゃ': 'time', '茎': 'cookie'　});\n * // sillyMap is passed defaultMapping to merge with when called in toRomaji()\n * toRomaji(\"It's 茎 ちゃ よ\", { customRomajiMapping: sillyMap });\n * // => 'It's cookie time yo';\n */\nexport function createCustomMapping(customMap = {}) {\n  const customTree = {};\n\n  if (typeOf(customMap) === 'object') {\n    Object.entries(customMap).forEach(([roma, kana]) => {\n      let subTree = customTree;\n      roma.split('').forEach((char) => {\n        if (subTree[char] === undefined) {\n          subTree[char] = {};\n        }\n        subTree = subTree[char];\n      });\n      subTree[''] = kana;\n    });\n  }\n\n  return function makeMap(map) {\n    const mapCopy = JSON.parse(JSON.stringify(map));\n\n    function transformMap(mapSubtree, customSubtree) {\n      if (mapSubtree === undefined || typeOf(mapSubtree) === 'string') {\n        return customSubtree;\n      }\n      return Object.entries(customSubtree).reduce(\n        (newSubtree, [char, subtree]) => {\n          // eslint-disable-next-line no-param-reassign\n          newSubtree[char] = transformMap(mapSubtree[char], subtree);\n          return newSubtree;\n        },\n        mapSubtree\n      );\n    }\n\n    return transformMap(mapCopy, customTree);\n  };\n}\n\n// allow consumer to pass either function or object as customMapping\nexport function mergeCustomMapping(map, customMapping) {\n  if (!customMapping) {\n    return map;\n  }\n  return typeOf(customMapping) === 'function'\n    ? customMapping(map)\n    : createCustomMapping(customMapping)(map);\n}\n","import { transform, getSubTreeOf, createCustomMapping } from './kanaMapping';\n\n// NOTE: not exactly kunrei shiki, for example ぢゃ -> dya instead of zya, to avoid name clashing\n/* eslint-disable */\n// prettier-ignore\nconst BASIC_KUNREI = {\n  a: 'あ', i: 'い', u: 'う', e: 'え', o: 'お',\n  k: { a: 'か', i: 'き', u: 'く', e: 'け', o: 'こ', },\n  s: { a: 'さ', i: 'し', u: 'す', e: 'せ', o: 'そ', },\n  t: { a: 'た', i: 'ち', u: 'つ', e: 'て', o: 'と', },\n  n: { a: 'な', i: 'に', u: 'ぬ', e: 'ね', o: 'の', },\n  h: { a: 'は', i: 'ひ', u: 'ふ', e: 'へ', o: 'ほ', },\n  m: { a: 'ま', i: 'み', u: 'む', e: 'め', o: 'も', },\n  y: { a: 'や', u: 'ゆ', o: 'よ' },\n  r: { a: 'ら', i: 'り', u: 'る', e: 'れ', o: 'ろ', },\n  w: { a: 'わ', i: 'ゐ', e: 'ゑ', o: 'を', },\n  g: { a: 'が', i: 'ぎ', u: 'ぐ', e: 'げ', o: 'ご', },\n  z: { a: 'ざ', i: 'じ', u: 'ず', e: 'ぜ', o: 'ぞ', },\n  d: { a: 'だ', i: 'ぢ', u: 'づ', e: 'で', o: 'ど', },\n  b: { a: 'ば', i: 'び', u: 'ぶ', e: 'べ', o: 'ぼ', },\n  p: { a: 'ぱ', i: 'ぴ', u: 'ぷ', e: 'ぺ', o: 'ぽ', },\n  v: { a: 'ゔぁ', i: 'ゔぃ', u: 'ゔ', e: 'ゔぇ', o: 'ゔぉ', },\n};\n\nconst SPECIAL_SYMBOLS = {\n  '.': '。',\n  ',': '、',\n  ':': '：',\n  '/': '・',\n  '!': '！',\n  '?': '？',\n  '~': '〜',\n  '-': 'ー',\n  '‘': '「',\n  '’': '」',\n  '“': '『',\n  '”': '』',\n  '[': '［',\n  ']': '］',\n  '(': '（',\n  ')': '）',\n  '{': '｛',\n  '}': '｝',\n};\n\nconst CONSONANTS = {\n  k: 'き',\n  s: 'し',\n  t: 'ち',\n  n: 'に',\n  h: 'ひ',\n  m: 'み',\n  r: 'り',\n  g: 'ぎ',\n  z: 'じ',\n  d: 'ぢ',\n  b: 'び',\n  p: 'ぴ',\n  v: 'ゔ',\n  q: 'く',\n  f: 'ふ',\n};\nconst SMALL_Y = { ya: 'ゃ', yi: 'ぃ', yu: 'ゅ', ye: 'ぇ', yo: 'ょ' };\nconst SMALL_VOWELS = { a: 'ぁ', i: 'ぃ', u: 'ぅ', e: 'ぇ', o: 'ぉ' };\n\n// typing one should be the same as having typed the other instead\nconst ALIASES = {\n  sh: 'sy', // sha -> sya\n  ch: 'ty', // cho -> tyo\n  cy: 'ty', // cyo -> tyo\n  chy: 'ty', // chyu -> tyu\n  shy: 'sy', // shya -> sya\n  j: 'zy', // ja -> zya\n  jy: 'zy', // jye -> zye\n\n  // exceptions to above rules\n  shi: 'si',\n  chi: 'ti',\n  tsu: 'tu',\n  ji: 'zi',\n  fu: 'hu',\n};\n\n// xtu -> っ\nconst SMALL_LETTERS = Object.assign(\n  {\n    tu: 'っ',\n    wa: 'ゎ',\n    ka: 'ヵ',\n    ke: 'ヶ',\n  },\n  SMALL_VOWELS,\n  SMALL_Y\n);\n\n// don't follow any notable patterns\nconst SPECIAL_CASES = {\n  yi: 'い',\n  wu: 'う',\n  ye: 'いぇ',\n  wi: 'うぃ',\n  we: 'うぇ',\n  kwa: 'くぁ',\n  whu: 'う',\n  // because it's not thya for てゃ but tha\n  // and tha is not てぁ, but てゃ\n  tha: 'てゃ',\n  thu: 'てゅ',\n  tho: 'てょ',\n  dha: 'でゃ',\n  dhu: 'でゅ',\n  dho: 'でょ',\n};\n\nconst AIUEO_CONSTRUCTIONS = {\n  wh: 'う',\n  kw: 'く',\n  qw: 'く',\n  q: 'く',\n  gw: 'ぐ',\n  sw: 'す',\n  ts: 'つ',\n  th: 'て',\n  tw: 'と',\n  dh: 'で',\n  dw: 'ど',\n  fw: 'ふ',\n  f: 'ふ',\n};\n\n/* eslint-enable */\nfunction createRomajiToKanaMap() {\n  const kanaTree = transform(BASIC_KUNREI);\n  // pseudo partial application\n  const subtreeOf = (string) => getSubTreeOf(kanaTree, string);\n\n  // add tya, sya, etc.\n  Object.entries(CONSONANTS).forEach(([consonant, yKana]) => {\n    Object.entries(SMALL_Y).forEach(([roma, kana]) => {\n      // for example kyo -> き + ょ\n      subtreeOf(consonant + roma)[''] = yKana + kana;\n    });\n  });\n\n  Object.entries(SPECIAL_SYMBOLS).forEach(([symbol, jsymbol]) => {\n    subtreeOf(symbol)[''] = jsymbol;\n  });\n\n  // things like うぃ, くぃ, etc.\n  Object.entries(AIUEO_CONSTRUCTIONS).forEach(([consonant, aiueoKana]) => {\n    Object.entries(SMALL_VOWELS).forEach(([vowel, kana]) => {\n      const subtree = subtreeOf(consonant + vowel);\n      subtree[''] = aiueoKana + kana;\n    });\n  });\n\n  // different ways to write ん\n  ['n', \"n'\", 'xn'].forEach((nChar) => {\n    subtreeOf(nChar)[''] = 'ん';\n  });\n\n  // c is equivalent to k, but not for chi, cha, etc. that's why we have to make a copy of k\n  kanaTree.c = JSON.parse(JSON.stringify(kanaTree.k));\n\n  Object.entries(ALIASES).forEach(([string, alternative]) => {\n    const allExceptLast = string.slice(0, string.length - 1);\n    const last = string.charAt(string.length - 1);\n    const parentTree = subtreeOf(allExceptLast);\n    // copy to avoid recursive containment\n    parentTree[last] = JSON.parse(JSON.stringify(subtreeOf(alternative)));\n  });\n\n  function getAlternatives(string) {\n    return [...Object.entries(ALIASES), ...[['c', 'k']]].reduce(\n      (list, [alt, roma]) => (string.startsWith(roma) ? list.concat(string.replace(roma, alt)) : list),\n      []\n    );\n  }\n\n  Object.entries(SMALL_LETTERS).forEach(([kunreiRoma, kana]) => {\n    const last = (char) => char.charAt(char.length - 1);\n    const allExceptLast = (chars) => chars.slice(0, chars.length - 1);\n    const xRoma = `x${kunreiRoma}`;\n    const xSubtree = subtreeOf(xRoma);\n    xSubtree[''] = kana;\n\n    // ltu -> xtu -> っ\n    const parentTree = subtreeOf(`l${allExceptLast(kunreiRoma)}`);\n    parentTree[last(kunreiRoma)] = xSubtree;\n\n    // ltsu -> ltu -> っ\n    getAlternatives(kunreiRoma).forEach((altRoma) => {\n      ['l', 'x'].forEach((prefix) => {\n        const altParentTree = subtreeOf(prefix + allExceptLast(altRoma));\n        altParentTree[last(altRoma)] = subtreeOf(prefix + kunreiRoma);\n      });\n    });\n  });\n\n  Object.entries(SPECIAL_CASES).forEach(([string, kana]) => {\n    subtreeOf(string)[''] = kana;\n  });\n\n  // add kka, tta, etc.\n  function addTsu(tree) {\n    return Object.entries(tree).reduce((tsuTree, [key, value]) => {\n      if (!key) {\n        // we have reached the bottom of this branch\n        // eslint-disable-next-line no-param-reassign\n        tsuTree[key] = `っ${value}`;\n      } else {\n        // more subtrees\n        // eslint-disable-next-line no-param-reassign\n        tsuTree[key] = addTsu(value);\n      }\n      return tsuTree;\n    }, {});\n  }\n  // have to explicitly name c here, because we made it a copy of k, not a reference\n  [...Object.keys(CONSONANTS), 'c', 'y', 'w', 'j'].forEach((consonant) => {\n    const subtree = kanaTree[consonant];\n    subtree[consonant] = addTsu(subtree);\n  });\n  // nn should not be っん\n  delete kanaTree.n.n;\n  // solidify the results, so that there there is referential transparency within the tree\n  return Object.freeze(JSON.parse(JSON.stringify(kanaTree)));\n}\n\nlet romajiToKanaMap = null;\n\nexport function getRomajiToKanaTree() {\n  if (romajiToKanaMap == null) {\n    romajiToKanaMap = createRomajiToKanaMap();\n  }\n  return romajiToKanaMap;\n}\n\nexport const USE_OBSOLETE_KANA_MAP = createCustomMapping({\n  wi: 'ゐ',\n  we: 'ゑ',\n});\n\nexport function IME_MODE_MAP(map) {\n  // in IME mode, we do not want to convert single ns\n  const mapCopy = JSON.parse(JSON.stringify(map));\n  mapCopy.n.n = { '': 'ん' };\n  mapCopy.n[' '] = { '': 'ん' };\n  return mapCopy;\n}\n","import isEmpty from './isEmpty';\nimport isCharInRange from './isCharInRange';\nimport { LATIN_UPPERCASE_START, LATIN_UPPERCASE_END } from '../constants.ts';\n\n/**\n * Tests if char is in English unicode uppercase range\n * @param  {String} char\n * @return {Boolean}\n */\nfunction isCharUpperCase(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharInRange(char, LATIN_UPPERCASE_START, LATIN_UPPERCASE_END);\n}\n\nexport default isCharUpperCase;\n","import isEmpty from './isEmpty';\nimport { PROLONGED_SOUND_MARK } from '../constants.ts';\n\n/**\n * Returns true if char is 'ー'\n * @param  {String} char to test\n * @return {Boolean}\n */\nfunction isCharLongDash(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;\n}\n\nexport default isCharLongDash;\n","import isEmpty from './isEmpty';\nimport { KANA_SLASH_DOT } from '../constants.ts';\n\n/**\n * Tests if char is '・'\n * @param  {String} char\n * @return {Boolean} true if '・'\n */\nfunction isCharSlashDot(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === KANA_SLASH_DOT;\n}\n\nexport default isCharSlashDot;\n","import isEmpty from './isEmpty';\nimport isCharLongDash from './isCharLongDash';\nimport isCharInRange from './isCharInRange';\nimport {\n  HIRAGANA_START,\n  HIRAGANA_END,\n} from '../constants.ts';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharHiragana(char = '') {\n  if (isEmpty(char)) return false;\n  if (isCharLongDash(char)) return true;\n  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);\n}\n\nexport default isCharHiragana;\n","import { KATAKANA_START, HIRAGANA_START } from '../constants.ts';\n\nimport isCharLongDash from './isCharLongDash';\nimport isCharSlashDot from './isCharSlashDot';\nimport isCharHiragana from './isCharHiragana';\n\n/**\n * Convert [Hiragana](https://en.wikipedia.org/wiki/Hiragana) to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * Passes through any non-hiragana chars\n * @private\n * @param  {String} [input=''] text input\n * @return {String} converted text\n * @example\n * hiraganaToKatakana('ひらがな')\n * // => \"ヒラガナ\"\n * hiraganaToKatakana('ひらがな is a type of kana')\n * // => \"ヒラガナ is a type of kana\"\n */\nfunction hiraganaToKatakana(input = '') {\n  const kata = [];\n  input.split('').forEach((char) => {\n    // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n    if (isCharLongDash(char) || isCharSlashDot(char)) {\n      kata.push(char);\n    } else if (isCharHiragana(char)) {\n      // Shift charcode.\n      const code = char.charCodeAt(0) + (KATAKANA_START - HIRAGANA_START);\n      const kataChar = String.fromCharCode(code);\n      kata.push(kataChar);\n    } else {\n      // Pass non-hiragana chars through\n      kata.push(char);\n    }\n  });\n  return kata.join('');\n}\n\nexport default hiraganaToKatakana;\n","import memoizeOne from 'memoize-one';\nimport { dequal } from 'dequal';\n\nimport { TO_KANA_METHODS } from './constants';\nimport mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport {\n  getRomajiToKanaTree,\n  IME_MODE_MAP,\n  USE_OBSOLETE_KANA_MAP,\n} from './utils/romajiToKanaMap';\nimport { applyMapping, mergeCustomMapping } from './utils/kanaMapping';\nimport isCharUpperCase from './utils/isCharUpperCase';\nimport hiraganaToKatakana from './utils/hiraganaToKatakana';\n\n// memoize and deeply compare args so we only recreate when necessary\nexport const createRomajiToKanaMap = memoizeOne(\n  (IMEMode, useObsoleteKana, customKanaMapping) => {\n    let map = getRomajiToKanaTree();\n\n    map = IMEMode ? IME_MODE_MAP(map) : map;\n    map = useObsoleteKana ? USE_OBSOLETE_KANA_MAP(map) : map;\n\n    if (customKanaMapping) {\n      map = mergeCustomMapping(map, customKanaMapping);\n    }\n\n    return map;\n  },\n  dequal\n);\n\n/**\n * Convert [Romaji](https://en.wikipedia.org/wiki/Romaji) to [Kana](https://en.wikipedia.org/wiki/Kana), lowercase text will result in [Hiragana](https://en.wikipedia.org/wiki/Hiragana) and uppercase text will result in [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @param  {Object.<string, string>} [map] custom mapping\n * @return {String} converted text\n * @example\n * toKana('onaji BUTTSUUJI')\n * // => 'おなじ ブッツウジ'\n * toKana('ONAJI buttsuuji')\n * // => 'オナジ ぶっつうじ'\n * toKana('座禅‘zazen’スタイル')\n * // => '座禅「ざぜん」スタイル'\n * toKana('batsuge-mu')\n * // => 'ばつげーむ'\n * toKana('!?.:/,~-‘’“”[](){}') // Punctuation conversion\n * // => '！？。：・、〜ー「」『』［］（）｛｝'\n * toKana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'bana' } });\n * // => 'わにbanaに'\n */\nexport function toKana(input = '', options = {}, map) {\n  let config;\n  if (!map) {\n    config = mergeWithDefaultOptions(options);\n    map = createRomajiToKanaMap(\n      config.IMEMode,\n      config.useObsoleteKana,\n      config.customKanaMapping\n    );\n  } else {\n    config = options;\n  }\n\n  // throw away the substring index information and just concatenate all the kana\n  return splitIntoConvertedKana(input, config, map)\n    .map((kanaToken) => {\n      const [start, end, kana] = kanaToken;\n      if (kana === null) {\n        // haven't converted the end of the string, since we are in IME mode\n        return input.slice(start);\n      }\n      const enforceHiragana = config.IMEMode === TO_KANA_METHODS.HIRAGANA;\n      const enforceKatakana = config.IMEMode === TO_KANA_METHODS.KATAKANA\n        || [...input.slice(start, end)].every(isCharUpperCase);\n\n      return enforceHiragana || !enforceKatakana\n        ? kana\n        : hiraganaToKatakana(kana);\n    })\n    .join('');\n}\n\n/**\n *\n * @private\n * @param {String} [input=''] input text\n * @param {DefaultOptions} [options=defaultOptions] toKana options\n * @param {Object} [map] custom mapping\n * @returns {Array[]} [[start, end, token]]\n * @example\n * splitIntoConvertedKana('buttsuuji')\n * // => [[0, 2, 'ぶ'], [2, 6, 'っつ'], [6, 7, 'う'], [7, 9, 'じ']]\n */\nexport function splitIntoConvertedKana(input = '', options = {}, map) {\n  const { IMEMode, useObsoleteKana, customKanaMapping } = options;\n\n  if (!map) {\n    map = createRomajiToKanaMap(IMEMode, useObsoleteKana, customKanaMapping);\n  }\n\n  return applyMapping(input.toLowerCase(), map, !IMEMode);\n}\n\nexport default toKana;\n","import isJapanese from '../isJapanese';\nimport toKana, { createRomajiToKanaMap } from '../toKana';\nimport mergeWithDefaultOptions from './mergeWithDefaultOptions';\n\nlet LISTENERS = [];\n/**\n * Automagically replaces input values with converted text to kana\n * @param  {defaultOptions} [options] user config overrides, default conversion is toKana()\n * @return {Function} event handler with bound options\n * @private\n */\nexport function makeOnInput(options) {\n  let prevInput;\n\n  // Enforce IMEMode if not already specified\n  const mergedConfig = Object.assign({}, mergeWithDefaultOptions(options), {\n    IMEMode: options.IMEMode || true,\n  });\n\n  const preConfiguredMap = createRomajiToKanaMap(\n    mergedConfig.IMEMode,\n    mergedConfig.useObsoleteKana,\n    mergedConfig.customKanaMapping\n  );\n\n  const triggers = [\n    ...Object.keys(preConfiguredMap),\n    ...Object.keys(preConfiguredMap).map((char) => char.toUpperCase()),\n  ];\n\n  return function onInput({ target }) {\n    if (\n      target.value !== prevInput\n      && target.dataset.ignoreComposition !== 'true'\n    ) {\n      convertInput(target, mergedConfig, preConfiguredMap, triggers, prevInput);\n    }\n  };\n}\n\nexport function convertInput(target, options, map, triggers, prevInput) {\n  const [head, textToConvert, tail] = splitInput(\n    target.value,\n    target.selectionEnd,\n    triggers\n  );\n  const convertedText = toKana(textToConvert, options, map);\n  const changed = textToConvert !== convertedText;\n\n  if (changed) {\n    const newCursor = head.length + convertedText.length;\n    const newValue = head + convertedText + tail;\n    // eslint-disable-next-line no-param-reassign\n    target.value = newValue;\n    // eslint-disable-next-line no-param-reassign\n    prevInput = newValue;\n\n    if (tail.length) {\n      // push later on event loop (otherwise mid-text insertion can be 1 char too far to the right)\n      setTimeout(() => target.setSelectionRange(newCursor, newCursor), 1);\n    } else {\n      target.setSelectionRange(newCursor, newCursor);\n    }\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    prevInput = target.value;\n  }\n}\n\nexport function onComposition({ type, target, data }) {\n  // navigator.platform is not 100% reliable for singling out all OS,\n  // but for determining desktop \"Mac OS\" it is effective enough.\n  const isMacOS = /Mac/.test(window.navigator && window.navigator.platform);\n  // We don't want to ignore on Android:\n  // https://github.com/WaniKani/WanaKana/issues/82\n  // But MacOS IME auto-closes if we don't ignore:\n  // https://github.com/WaniKani/WanaKana/issues/71\n  // Other platform Japanese IMEs pass through happily\n  if (isMacOS) {\n    if (type === 'compositionupdate' && isJapanese(data)) {\n      // eslint-disable-next-line no-param-reassign\n      target.dataset.ignoreComposition = 'true';\n    }\n\n    if (type === 'compositionend') {\n      // eslint-disable-next-line no-param-reassign\n      target.dataset.ignoreComposition = 'false';\n    }\n  }\n}\n\nexport function trackListeners(id, inputHandler, compositionHandler) {\n  LISTENERS = LISTENERS.concat({\n    id,\n    inputHandler,\n    compositionHandler,\n  });\n}\n\nexport function untrackListeners({ id: targetId }) {\n  LISTENERS = LISTENERS.filter(({ id }) => id !== targetId);\n}\n\nexport function findListeners(el) {\n  return (\n    el && LISTENERS.find(({ id }) => id === el.getAttribute('data-wanakana-id'))\n  );\n}\n\n// Handle non-terminal inserted input conversion:\n// | -> わ| -> わび| -> わ|び -> わs|び -> わsh|び -> わshi|び -> わし|び\n// or multiple ambiguous positioning (to select which \"s\" to work from)\n// こsこs|こsこ -> こsこso|こsこ -> こsこそ|こsこ\nexport function splitInput(text = '', cursor = 0, triggers = []) {\n  let head;\n  let toConvert;\n  let tail;\n\n  if (cursor === 0 && triggers.includes(text[0])) {\n    [head, toConvert, tail] = workFromStart(text, triggers);\n  } else if (cursor > 0) {\n    [head, toConvert, tail] = workBackwards(text, cursor);\n  } else {\n    [head, toConvert] = takeWhileAndSlice(\n      text,\n      (char) => !triggers.includes(char)\n    );\n    [toConvert, tail] = takeWhileAndSlice(\n      toConvert,\n      (char) => !isJapanese(char)\n    );\n  }\n\n  return [head, toConvert, tail];\n}\n\nfunction workFromStart(text, catalystChars) {\n  return [\n    '',\n    ...takeWhileAndSlice(\n      text,\n      (char) => catalystChars.includes(char) || !isJapanese(char, /[0-9]/)\n    ),\n  ];\n}\n\nfunction workBackwards(text = '', startIndex = 0) {\n  const [toConvert, head] = takeWhileAndSlice(\n    [...text.slice(0, startIndex)].reverse(),\n    (char) => !isJapanese(char)\n  );\n  return [\n    head.reverse().join(''),\n    toConvert\n      .split('')\n      .reverse()\n      .join(''),\n    text.slice(startIndex),\n  ];\n}\n\nfunction takeWhileAndSlice(source = {}, predicate = (x) => !!x) {\n  const result = [];\n  const { length } = source;\n  let i = 0;\n  while (i < length && predicate(source[i], i)) {\n    result.push(source[i]);\n    i += 1;\n  }\n  return [result.join(''), source.slice(i)];\n}\n","/* eslint-disable no-console */\nconst onInput = ({ target: { value, selectionStart, selectionEnd } }) => console.log('input:', { value, selectionStart, selectionEnd });\nconst onCompositionStart = () => console.log('compositionstart');\nconst onCompositionUpdate = ({\n  target: { value, selectionStart, selectionEnd },\n  data,\n}) => console.log('compositionupdate', {\n  data,\n  value,\n  selectionStart,\n  selectionEnd,\n});\nconst onCompositionEnd = () => console.log('compositionend');\n\nconst events = {\n  input: onInput,\n  compositionstart: onCompositionStart,\n  compositionupdate: onCompositionUpdate,\n  compositionend: onCompositionEnd,\n};\n\nexport const addDebugListeners = (input) => {\n  Object.entries(events).forEach(([event, handler]) => input.addEventListener(event, handler)\n  );\n};\n\nexport const removeDebugListeners = (input) => {\n  Object.entries(events).forEach(([event, handler]) => input.removeEventListener(event, handler)\n  );\n};\n","import { makeOnInput, onComposition, trackListeners } from './utils/dom';\nimport { addDebugListeners } from './utils/logInputEvents';\n\nconst ELEMENTS = ['TEXTAREA', 'INPUT'];\n\nlet idCounter = 0;\nconst newId = () => {\n  idCounter += 1;\n  return `${Date.now()}${idCounter}`;\n};\n\n/**\n * Binds eventListener for 'input' events to an input field to automagically replace values with kana\n * Can pass `{ IMEMode: 'toHiragana' || 'toKatakana' }` to enforce kana conversion type\n * @param  {HTMLInputElement | HTMLTextAreaElement} element textarea, input[type=\"text\"] etc\n * @param  {DefaultOptions} [options=defaultOptions] defaults to { IMEMode: true } using `toKana`\n * @example\n * bind(document.querySelector('#myInput'));\n */\nfunction bind(element = {}, options = {}, debug = false) {\n  if (!ELEMENTS.includes(element.nodeName)) {\n    throw new Error(\n      `Element provided to Wanakana bind() was not a valid input or textarea element.\\n Received: (${JSON.stringify(\n        element\n      )})`\n    );\n  }\n  if (element.hasAttribute('data-wanakana-id')) {\n    return;\n  }\n  const onInput = makeOnInput(options);\n  const id = newId();\n  const attributes = [\n    { name: 'data-wanakana-id', value: id },\n    { name: 'lang', value: 'ja' },\n    { name: 'autoCapitalize', value: 'none' },\n    { name: 'autoCorrect', value: 'off' },\n    { name: 'autoComplete', value: 'off' },\n    { name: 'spellCheck', value: 'false' },\n  ];\n  const previousAttributes = {};\n  attributes.forEach((attribute) => {\n    previousAttributes[attribute.name] = element.getAttribute(attribute.name);\n    element.setAttribute(attribute.name, attribute.value);\n  });\n  element.dataset.previousAttributes = JSON.stringify(previousAttributes);\n  element.addEventListener('input', onInput);\n  element.addEventListener('compositionupdate', onComposition);\n  element.addEventListener('compositionend', onComposition);\n  trackListeners(id, onInput, onComposition);\n  if (debug === true) {\n    addDebugListeners(element);\n  }\n}\n\nexport default bind;\n","import { findListeners, untrackListeners } from './utils/dom';\nimport { removeDebugListeners } from './utils/logInputEvents';\n\n/**\n * Unbinds eventListener from input field\n * @param  {HTMLInputElement | HTMLTextAreaElement} element textarea, input\n */\nexport function unbind(element, debug = false) {\n  const listeners = findListeners(element);\n  if (listeners == null) {\n    throw new Error(\n      `Element provided to Wanakana unbind() had no listener registered.\\n Received: ${JSON.stringify(\n        element\n      )}`\n    );\n  }\n  const { inputHandler, compositionHandler } = listeners;\n  const attributes = JSON.parse(element.dataset.previousAttributes);\n  Object.keys(attributes).forEach((key) => {\n    if (attributes[key]) {\n      element.setAttribute(key, attributes[key]);\n    } else {\n      element.removeAttribute(key);\n    }\n  });\n  element.removeAttribute('data-previous-attributes');\n  element.removeAttribute('data-ignore-composition');\n  element.removeEventListener('input', inputHandler);\n  element.removeEventListener('compositionstart', compositionHandler);\n  element.removeEventListener('compositionupdate', compositionHandler);\n  element.removeEventListener('compositionend', compositionHandler);\n  untrackListeners(listeners);\n  if (debug === true) {\n    removeDebugListeners(element);\n  }\n}\n\nexport default unbind;\n","import isEmpty from './isEmpty';\nimport isCharInRange from './isCharInRange';\nimport { ROMAJI_RANGES } from '../constants.ts';\n\n/**\n * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharRomaji(char = '') {\n  if (isEmpty(char)) return false;\n  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharRomaji;\n","import typeOf from './utils/typeOf';\nimport isEmpty from './utils/isEmpty';\nimport isCharRomaji from './utils/isCharRomaji';\n\n/**\n * Test if `input` is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} [input=''] text\n * @param  {RegExp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if [Romaji](https://en.wikipedia.org/wiki/Romaji)\n * @example\n * isRomaji('Tōkyō and Ōsaka')\n * // => true\n * isRomaji('12a*b&c-d')\n * // => true\n * isRomaji('あアA')\n * // => false\n * isRomaji('お願い')\n * // => false\n * isRomaji('a！b&cーd') // Zenkaku punctuation fails\n * // => false\n * isRomaji('a！b&cーd', /[！ー]/)\n * // => true\n */\nfunction isRomaji(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input)\n    ? false\n    : [...input].every((char) => {\n      const isRoma = isCharRomaji(char);\n      return !augmented ? isRoma : isRoma || allowed.test(char);\n    });\n}\n\nexport default isRomaji;\n","import {\n  KATAKANA_START,\n  KATAKANA_END,\n} from '../constants.ts';\n\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKatakana(char = '') {\n  return isCharInRange(char, KATAKANA_START, KATAKANA_END);\n}\n\nexport default isCharKatakana;\n","import isEmpty from './isEmpty';\nimport isCharHiragana from './isCharHiragana';\nimport isCharKatakana from './isCharKatakana';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKana(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharHiragana(char) || isCharKatakana(char);\n}\n\nexport default isCharKana;\n","import isEmpty from './utils/isEmpty';\nimport isCharKana from './utils/isCharKana';\n\n/**\n * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)\n * @example\n * isKana('あ')\n * // => true\n * isKana('ア')\n * // => true\n * isKana('あーア')\n * // => true\n * isKana('A')\n * // => false\n * isKana('あAア')\n * // => false\n */\nfunction isKana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKana);\n}\n\nexport default isKana;\n","import isEmpty from './utils/isEmpty';\nimport isCharHiragana from './utils/isCharHiragana';\n\n/**\n * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @example\n * isHiragana('げーむ')\n * // => true\n * isHiragana('A')\n * // => false\n * isHiragana('あア')\n * // => false\n */\nfunction isHiragana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharHiragana);\n}\n\nexport default isHiragana;\n","import isEmpty from './utils/isEmpty';\nimport isCharKatakana from './utils/isCharKatakana';\n\n/**\n * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @example\n * isKatakana('ゲーム')\n * // => true\n * isKatakana('あ')\n * // => false\n * isKatakana('A')\n * // => false\n * isKatakana('あア')\n * // => false\n */\nfunction isKatakana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKatakana);\n}\n\nexport default isKatakana;\n","import isEmpty from './isEmpty';\nimport { KANJI_ITERATION_MARK } from '../constants.ts';\n\n/**\n * Returns true if char is '々'\n * @param  {String} char to test\n * @return {Boolean}\n */\nfunction isCharIterationMark(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === KANJI_ITERATION_MARK;\n}\n\nexport default isCharIterationMark;\n","import { KANJI_START, KANJI_END } from '../constants.ts';\n\nimport isCharInRange from './isCharInRange';\nimport isCharIterationMark from './isCharIterationMark';\n/**\n * Tests a character. Returns true if the character is a CJK ideograph (kanji).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKanji(char = '') {\n  return isCharInRange(char, KANJI_START, KANJI_END) || isCharIterationMark(char);\n}\n\nexport default isCharKanji;\n","import isEmpty from './utils/isEmpty';\nimport isCharKanji from './utils/isCharKanji';\n\n/**\n * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @example\n * isKanji('刀')\n * // => true\n * isKanji('切腹')\n * // => true\n * isKanji('勢い')\n * // => false\n * isKanji('あAア')\n * // => false\n * isKanji('🐸')\n * // => false\n */\nfunction isKanji(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKanji);\n}\n\nexport default isKanji;\n","import isKanji from './isKanji';\nimport isHiragana from './isHiragana';\nimport isKatakana from './isKatakana';\nimport isRomaji from './isRomaji';\n\n/**\n * Test if `input` contains a mix of [Romaji](https://en.wikipedia.org/wiki/Romaji) *and* [Kana](https://en.wikipedia.org/wiki/Kana), defaults to pass through [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @param  {String} input text\n * @param  {{ passKanji: Boolean}} [options={ passKanji: true }] optional config to pass through kanji\n * @return {Boolean} true if mixed\n * @example\n * isMixed('Abあア'))\n * // => true\n * isMixed('お腹A')) // ignores kanji by default\n * // => true\n * isMixed('お腹A', { passKanji: false }))\n * // => false\n * isMixed('ab'))\n * // => false\n * isMixed('あア'))\n * // => false\n */\nfunction isMixed(input = '', options = { passKanji: true }) {\n  const chars = [...input];\n  let hasKanji = false;\n  if (!options.passKanji) {\n    hasKanji = chars.some(isKanji);\n  }\n  return (chars.some(isHiragana) || chars.some(isKatakana)) && chars.some(isRomaji) && !hasKanji;\n}\n\nexport default isMixed;\n","import { KATAKANA_START, HIRAGANA_START } from '../constants.ts';\n\nimport isCharLongDash from './isCharLongDash';\nimport isCharSlashDot from './isCharSlashDot';\nimport isCharKatakana from './isCharKatakana';\nconst isCharInitialLongDash = (char, index) => isCharLongDash(char) && index < 1;\nconst isCharInnerLongDash = (char, index) => isCharLongDash(char) && index > 0;\nconst isKanaAsSymbol = (char) => ['ヶ', 'ヵ'].includes(char);\nconst LONG_VOWELS = {\n  a: 'あ',\n  i: 'い',\n  u: 'う',\n  e: 'え',\n  o: 'う',\n};\n\n// inject toRomaji to avoid circular dependency between toRomaji <-> katakanaToHiragana\nfunction katakanaToHiragana(\n  input = '',\n  toRomaji,\n  { isDestinationRomaji, convertLongVowelMark } = {}\n) {\n  let previousKana = '';\n\n  return input\n    .split('')\n    .reduce((hira, char, index) => {\n      // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n      if (\n        isCharSlashDot(char)\n        || isCharInitialLongDash(char, index)\n        || isKanaAsSymbol(char)\n      ) {\n        return hira.concat(char);\n      }\n\n      // Transform long vowels: 'オー' to 'おう'\n      if (\n        convertLongVowelMark\n        && previousKana\n        && isCharInnerLongDash(char, index)\n      ) {\n        // Transform previousKana back to romaji, and slice off the vowel\n        const romaji = toRomaji(previousKana).slice(-1);\n        // However, ensure 'オー' => 'おお' => 'oo' if this is a transform on the way to romaji\n        if (\n          isCharKatakana(input[index - 1])\n          && romaji === 'o'\n          && isDestinationRomaji\n        ) {\n          return hira.concat('お');\n        }\n        return hira.concat(LONG_VOWELS[romaji]);\n        // Transform all other chars\n      }\n\n      if (!isCharLongDash(char) && isCharKatakana(char)) {\n        const code = char.charCodeAt(0) + (HIRAGANA_START - KATAKANA_START);\n        const hiraChar = String.fromCharCode(code);\n        previousKana = hiraChar;\n        return hira.concat(hiraChar);\n      }\n\n      // Pass non katakana chars through\n      previousKana = '';\n      return hira.concat(char);\n    }, [])\n    .join('');\n}\n\nexport default katakanaToHiragana;\n","import { transform, getSubTreeOf } from './kanaMapping';\nimport { ROMANIZATIONS } from '../constants.ts';\n\nlet kanaToHepburnMap = null;\n\n/* eslint-disable */\n// prettier-ignore\nconst BASIC_ROMAJI = {\n  あ:'a',    い:'i',   う:'u',   え:'e',    お:'o',\n  か:'ka',   き:'ki',  く:'ku',  け:'ke',   こ:'ko',\n  さ:'sa',   し:'shi', す:'su',  せ:'se',   そ:'so',\n  た:'ta',   ち:'chi', つ:'tsu', て:'te',   と:'to',\n  な:'na',   に:'ni',  ぬ:'nu',  ね:'ne',   の:'no',\n  は:'ha',   ひ:'hi',  ふ:'fu',  へ:'he',   ほ:'ho',\n  ま:'ma',   み:'mi',  む:'mu',  め:'me',   も:'mo',\n  ら:'ra',   り:'ri',  る:'ru',  れ:'re',   ろ:'ro',\n  や:'ya',   ゆ:'yu',  よ:'yo',\n  わ:'wa',   ゐ:'wi',  ゑ:'we',  を:'wo',\n  ん: 'n',\n  が:'ga',   ぎ:'gi',  ぐ:'gu',  げ:'ge',   ご:'go',\n  ざ:'za',   じ:'ji',  ず:'zu',  ぜ:'ze',   ぞ:'zo',\n  だ:'da',   ぢ:'ji',  づ:'zu',  で:'de',   ど:'do',\n  ば:'ba',   び:'bi',  ぶ:'bu',  べ:'be',   ぼ:'bo',\n  ぱ:'pa',   ぴ:'pi',  ぷ:'pu',  ぺ:'pe',   ぽ:'po',\n  ゔぁ:'va', ゔぃ:'vi', ゔ:'vu',  ゔぇ:'ve', ゔぉ:'vo',\n};\n/* eslint-enable  */\n\nconst SPECIAL_SYMBOLS = {\n  '。': '.',\n  '、': ',',\n  '：': ':',\n  '・': '/',\n  '！': '!',\n  '？': '?',\n  '〜': '~',\n  'ー': '-',\n  '「': '‘',\n  '」': '’',\n  '『': '“',\n  '』': '”',\n  '［': '[',\n  '］': ']',\n  '（': '(',\n  '）': ')',\n  '｛': '{',\n  '｝': '}',\n  '　': ' ',\n};\n\n// んい -> n'i\nconst AMBIGUOUS_VOWELS = ['あ', 'い', 'う', 'え', 'お', 'や', 'ゆ', 'よ'];\nconst SMALL_Y = { ゃ: 'ya', ゅ: 'yu', ょ: 'yo' };\nconst SMALL_Y_EXTRA = { ぃ: 'yi', ぇ: 'ye' };\nconst SMALL_AIUEO = {\n  ぁ: 'a',\n  ぃ: 'i',\n  ぅ: 'u',\n  ぇ: 'e',\n  ぉ: 'o',\n};\nconst YOON_KANA = [\n  'き',\n  'に',\n  'ひ',\n  'み',\n  'り',\n  'ぎ',\n  'び',\n  'ぴ',\n  'ゔ',\n  'く',\n  'ふ',\n];\nconst YOON_EXCEPTIONS = {\n  し: 'sh',\n  ち: 'ch',\n  じ: 'j',\n  ぢ: 'j',\n};\nconst SMALL_KANA = {\n  っ: '',\n  ゃ: 'ya',\n  ゅ: 'yu',\n  ょ: 'yo',\n  ぁ: 'a',\n  ぃ: 'i',\n  ぅ: 'u',\n  ぇ: 'e',\n  ぉ: 'o',\n};\n\n// going with the intuitive (yet incorrect) solution where っや -> yya and っぃ -> ii\n// in other words, just assume the sokuon could have been applied to anything\nconst SOKUON_WHITELIST = {\n  b: 'b',\n  c: 't',\n  d: 'd',\n  f: 'f',\n  g: 'g',\n  h: 'h',\n  j: 'j',\n  k: 'k',\n  m: 'm',\n  p: 'p',\n  q: 'q',\n  r: 'r',\n  s: 's',\n  t: 't',\n  v: 'v',\n  w: 'w',\n  x: 'x',\n  z: 'z',\n};\n\nfunction getKanaToHepburnTree() {\n  if (kanaToHepburnMap == null) {\n    kanaToHepburnMap = createKanaToHepburnMap();\n  }\n  return kanaToHepburnMap;\n}\n\nexport function getKanaToRomajiTree(romanization) {\n  switch (romanization) {\n    case ROMANIZATIONS.HEPBURN:\n      return getKanaToHepburnTree();\n    default:\n      return {};\n  }\n}\n\nfunction createKanaToHepburnMap() {\n  const romajiTree = transform(BASIC_ROMAJI);\n\n  const subtreeOf = (string) => getSubTreeOf(romajiTree, string);\n  const setTrans = (string, transliteration) => {\n    subtreeOf(string)[''] = transliteration;\n  };\n\n  Object.entries(SPECIAL_SYMBOLS).forEach(([jsymbol, symbol]) => {\n    subtreeOf(jsymbol)[''] = symbol;\n  });\n\n  [...Object.entries(SMALL_Y), ...Object.entries(SMALL_AIUEO)].forEach(\n    ([roma, kana]) => {\n      setTrans(roma, kana);\n    }\n  );\n\n  // きゃ -> kya\n  YOON_KANA.forEach((kana) => {\n    const firstRomajiChar = subtreeOf(kana)[''][0];\n    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, firstRomajiChar + yRoma);\n    });\n    // きぃ -> kyi\n    Object.entries(SMALL_Y_EXTRA).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, firstRomajiChar + yRoma);\n    });\n  });\n\n  Object.entries(YOON_EXCEPTIONS).forEach(([kana, roma]) => {\n    // じゃ -> ja\n    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, roma + yRoma[1]);\n    });\n    // じぃ -> jyi, じぇ -> je\n    setTrans(`${kana}ぃ`, `${roma}yi`);\n    setTrans(`${kana}ぇ`, `${roma}e`);\n  });\n\n  romajiTree['っ'] = resolveTsu(romajiTree);\n\n  Object.entries(SMALL_KANA).forEach(([kana, roma]) => {\n    setTrans(kana, roma);\n  });\n\n  AMBIGUOUS_VOWELS.forEach((kana) => {\n    setTrans(`ん${kana}`, `n'${subtreeOf(kana)['']}`);\n  });\n\n  // NOTE: could be re-enabled with an option?\n  // // んば -> mbo\n  // const LABIAL = [\n  //   'ば', 'び', 'ぶ', 'べ', 'ぼ',\n  //   'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ',\n  //   'ま', 'み', 'む', 'め', 'も',\n  // ];\n  // LABIAL.forEach((kana) => {\n  //   setTrans(`ん${kana}`, `m${subtreeOf(kana)['']}`);\n  // });\n\n  return Object.freeze(JSON.parse(JSON.stringify(romajiTree)));\n}\n\nfunction resolveTsu(tree) {\n  return Object.entries(tree).reduce((tsuTree, [key, value]) => {\n    if (!key) {\n      // we have reached the bottom of this branch\n      const consonant = value.charAt(0);\n      // eslint-disable-next-line no-param-reassign\n      tsuTree[key] = Object.keys(SOKUON_WHITELIST).includes(consonant)\n        ? SOKUON_WHITELIST[consonant] + value\n        : value;\n    } else {\n      // more subtrees\n      // eslint-disable-next-line no-param-reassign\n      tsuTree[key] = resolveTsu(value);\n    }\n    return tsuTree;\n  }, {});\n}\n","import memoizeOne from 'memoize-one';\nimport { dequal } from 'dequal';\n\nimport mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport katakanaToHiragana from './utils/katakanaToHiragana';\nimport isKatakana from './isKatakana';\nimport { getKanaToRomajiTree } from './utils/kanaToRomajiMap';\nimport { applyMapping, mergeCustomMapping } from './utils/kanaMapping';\n\n// memoize and deeply compare args so we only recreate when necessary\nexport const createKanaToRomajiMap = memoizeOne(\n  (romanization, customRomajiMapping) => {\n    let map = getKanaToRomajiTree(romanization);\n\n    if (customRomajiMapping) {\n      map = mergeCustomMapping(map, customRomajiMapping);\n    }\n\n    return map;\n  },\n  dequal\n);\n\n/**\n * Convert kana to romaji\n * @param  {String} kana text input\n * @param  {DefaultOptions} [options=defaultOptions]\n * @param  {Object.<string, string>} [map] custom mapping\n * @return {String} converted text\n * @example\n * toRomaji('ひらがな　カタカナ')\n * // => 'hiragana katakana'\n * toRomaji('げーむ　ゲーム')\n * // => 'ge-mu geemu'\n * toRomaji('ひらがな　カタカナ', { upcaseKatakana: true })\n * // => 'hiragana KATAKANA'\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' } });\n * // => 'tuzigili'\n */\nexport function toRomaji(input = '', options = {}, map) {\n  const config = mergeWithDefaultOptions(options);\n\n  if (!map) {\n    map = createKanaToRomajiMap(\n      config.romanization,\n      config.customRomajiMapping\n    );\n  }\n\n  // just throw away the substring index information and simply concatenate all the kana\n  return splitIntoRomaji(input, config, map)\n    .map((romajiToken) => {\n      const [start, end, romaji] = romajiToken;\n      const makeUpperCase = config.upcaseKatakana && isKatakana(input.slice(start, end));\n      return makeUpperCase ? romaji.toUpperCase() : romaji;\n    })\n    .join('');\n}\n\nfunction splitIntoRomaji(input, options, map) {\n  if (!map) {\n    map = createKanaToRomajiMap(\n      options.romanization,\n      options.customRomajiMapping\n    );\n  }\n\n  const config = Object.assign({}, { isDestinationRomaji: true }, options);\n\n  return applyMapping(\n    katakanaToHiragana(input, toRomaji, config),\n    map,\n    !options.IMEMode\n  );\n}\n\nexport default toRomaji;\n","import isEmpty from './isEmpty';\nimport { EN_PUNCTUATION_RANGES } from '../constants.ts';\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharEnglishPunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharEnglishPunctuation;\n","import mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport katakanaToHiragana from './utils/katakanaToHiragana';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isRomaji from './isRomaji';\nimport isMixed from './isMixed';\nimport toKana from './toKana';\nimport toRomaji from './toRomaji';\n\n/**\n * Convert input to [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toHiragana('toukyou, オオサカ')\n * // => 'とうきょう、　おおさか'\n * toHiragana('only カナ', { passRomaji: true })\n * // => 'only かな'\n * toHiragana('wi')\n * // => 'うぃ'\n * toHiragana('wi', { useObsoleteKana: true })\n * // => 'ゐ'\n */\nfunction toHiragana(input = '', options = {}) {\n  const config = mergeWithDefaultOptions(options);\n  if (config.passRomaji) {\n    return katakanaToHiragana(input, toRomaji, config);\n  }\n\n  if (isMixed(input, { passKanji: true })) {\n    const convertedKatakana = katakanaToHiragana(input, toRomaji, config);\n    return toKana(convertedKatakana.toLowerCase(), config);\n  }\n\n  if (isRomaji(input) || isCharEnglishPunctuation(input)) {\n    return toKana(input.toLowerCase(), config);\n  }\n\n  return katakanaToHiragana(input, toRomaji, config);\n}\n\nexport default toHiragana;\n","import mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport hiraganaToKatakana from './utils/hiraganaToKatakana';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport toKana from './toKana';\nimport isRomaji from './isRomaji';\nimport isMixed from './isMixed';\n\n/**\n * Convert input to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toKatakana('toukyou, おおさか')\n * // => 'トウキョウ、　オオサカ'\n * toKatakana('only かな', { passRomaji: true })\n * // => 'only カナ'\n * toKatakana('wi')\n * // => 'ウィ'\n * toKatakana('wi', { useObsoleteKana: true })\n * // => 'ヰ'\n */\nfunction toKatakana(input = '', options = {}) {\n  const mergedOptions = mergeWithDefaultOptions(options);\n  if (mergedOptions.passRomaji) {\n    return hiraganaToKatakana(input);\n  }\n\n  if (isMixed(input) || isRomaji(input) || isCharEnglishPunctuation(input)) {\n    const hiragana = toKana(input.toLowerCase(), mergedOptions);\n    return hiraganaToKatakana(hiragana);\n  }\n\n  return hiraganaToKatakana(input);\n}\n\nexport default toKatakana;\n","import isEmpty from './isEmpty';\nimport { JA_PUNCTUATION_RANGES } from '../constants.ts';\nimport isCharInRange from './isCharInRange';\nimport isCharIterationMark from './isCharIterationMark';\n\n/**\n * Tests a character. Returns true if the character is considered Japanese punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanesePunctuation(char = '') {\n  if (isEmpty(char) || isCharIterationMark(char)) return false;\n  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanesePunctuation;\n","import isEmpty from './utils/isEmpty';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isCharJapanesePunctuation from './utils/isCharJapanesePunctuation';\nimport isCharRomaji from './utils/isCharRomaji';\nimport isCharKanji from './utils/isCharKanji';\nimport isCharHiragana from './utils/isCharHiragana';\nimport isCharKatakana from './utils/isCharKatakana';\nimport isCharJapanese from './utils/isCharJapanese';\n\nconst isCharEnSpace = (x) => x === ' ';\nconst isCharJaSpace = (x) => x === '　';\nconst isCharJaNum = (x) => /[０-９]/.test(x);\nconst isCharEnNum = (x) => /[0-9]/.test(x);\n\nconst TOKEN_TYPES = {\n  EN: 'en',\n  JA: 'ja',\n  EN_NUM: 'englishNumeral',\n  JA_NUM: 'japaneseNumeral',\n  EN_PUNC: 'englishPunctuation',\n  JA_PUNC: 'japanesePunctuation',\n  KANJI: 'kanji',\n  HIRAGANA: 'hiragana',\n  KATAKANA: 'katakana',\n  SPACE: 'space',\n  OTHER: 'other',\n};\n\n// prettier-ignore\nexport function getType(input, compact = false) {\n  const {\n    EN, JA, EN_NUM, JA_NUM, EN_PUNC, JA_PUNC, KANJI, HIRAGANA, KATAKANA, SPACE, OTHER,\n  } = TOKEN_TYPES;\n\n  if (compact) {\n    switch (true) {\n      case isCharJaNum(input): return OTHER;\n      case isCharEnNum(input): return OTHER;\n      case isCharEnSpace(input): return EN;\n      case isCharEnglishPunctuation(input): return OTHER;\n      case isCharJaSpace(input): return JA;\n      case isCharJapanesePunctuation(input): return OTHER;\n      case isCharJapanese(input): return JA;\n      case isCharRomaji(input): return EN;\n      default: return OTHER;\n    }\n  } else {\n    switch (true) {\n      case isCharJaSpace(input): return SPACE;\n      case isCharEnSpace(input): return SPACE;\n      case isCharJaNum(input): return JA_NUM;\n      case isCharEnNum(input): return EN_NUM;\n      case isCharEnglishPunctuation(input): return EN_PUNC;\n      case isCharJapanesePunctuation(input): return JA_PUNC;\n      case isCharKanji(input): return KANJI;\n      case isCharHiragana(input): return HIRAGANA;\n      case isCharKatakana(input): return KATAKANA;\n      case isCharJapanese(input): return JA;\n      case isCharRomaji(input): return EN;\n      default: return OTHER;\n    }\n  }\n}\n\n/**\n * Splits input into array of strings separated by opinionated token types\n * `'en', 'ja', 'englishNumeral', 'japaneseNumeral','englishPunctuation', 'japanesePunctuation','kanji', 'hiragana', 'katakana', 'space', 'other'`.\n * If `{ compact: true }` then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation).\n * If `{ detailed: true }` then return array will contain `{ type, value }` instead of `'value'`\n * @param  {String} input text\n * @param  {{compact: Boolean | undefined, detailed: Boolean | undefined}} [options={ compact: false, detailed: false}] options to modify output style\n * @return {(String[]|Array.<{type: String, value: String}>)} text split into tokens containing values, or detailed object\n * @example\n * tokenize('ふふフフ')\n * // ['ふふ', 'フフ']\n *\n * tokenize('感じ')\n * // ['感', 'じ']\n *\n * tokenize('人々')\n * // ['人々']\n *\n * tokenize('truly 私は悲しい')\n * // ['truly', ' ', '私', 'は', '悲', 'しい']\n *\n * tokenize('truly 私は悲しい', { compact: true })\n * // ['truly ', '私は悲しい']\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！')\n * // [ '5', 'romaji', ' ', 'here', '...!?', '人々漢字', 'ひらがな', 'カタ', '　', 'カナ', '４', '「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！', { compact: true })\n * // [ '5', 'romaji here', '...!?', '人々漢字ひらがなカタ　カナ', '４「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { detailed: true })\n * // [\n *  { type: 'englishNumeral', value: '5' },\n *  { type: 'en', value: 'romaji' },\n *  { type: 'space', value: ' ' },\n *  { type: 'en', value: 'here' },\n *  { type: 'englishPunctuation', value: '...!?' },\n *  { type: 'kanji', value: '人々漢字' },\n *  { type: 'hiragana', value: 'ひらがな' },\n *  { type: 'katakana', value: 'カタ' },\n *  { type: 'space', value: '　' },\n *  { type: 'katakana', value: 'カナ' },\n *  { type: 'japaneseNumeral', value: '４' },\n *  { type: 'japanesePunctuation', value: '「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'japanesePunctuation', value: '」。！' },\n *  { type: 'space', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n * ]\n *\n * tokenize('5romaji here...!?人々漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { compact: true, detailed: true})\n * // [\n *  { type: 'other', value: '5' },\n *  { type: 'en', value: 'romaji here' },\n *  { type: 'other', value: '...!?' },\n *  { type: 'ja', value: '人々漢字ひらがなカタ　カナ' },\n *  { type: 'other', value: '４「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'other', value: '」。！' },\n *  { type: 'en', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n *]\n */\nfunction tokenize(input, { compact = false, detailed = false } = {}) {\n  if (input == null || isEmpty(input)) {\n    return [];\n  }\n  const chars = [...input];\n  let initial = chars.shift();\n  let prevType = getType(initial, compact);\n  initial = detailed ? { type: prevType, value: initial } : initial;\n\n  const result = chars.reduce(\n    (tokens, char) => {\n      const currType = getType(char, compact);\n      const sameType = currType === prevType;\n      prevType = currType;\n      let newValue = char;\n\n      if (sameType) {\n        newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;\n      }\n\n      return detailed\n        ? tokens.concat({ type: currType, value: newValue })\n        : tokens.concat(newValue);\n    },\n    [initial]\n  );\n  return result;\n}\n\nexport default tokenize;\n","import isJapanese from './isJapanese';\nimport isKana from './isKana';\nimport isKanji from './isKanji';\nimport tokenize from './tokenize';\n\nconst isLeadingWithoutInitialKana = (input, leading) => leading && !isKana(input[0]);\nconst isTrailingWithoutFinalKana = (input, leading) => !leading && !isKana(input[input.length - 1]);\nconst isInvalidMatcher = (input, matchKanji) =>\n  (matchKanji && ![...matchKanji].some(isKanji)) || (!matchKanji && isKana(input));\n\n/**\n * Strips [Okurigana](https://en.wikipedia.org/wiki/Okurigana)\n * @param  {String} input text\n * @param  {{ leading: Boolean | undefined, matchKanji: string | undefined }} [options={ leading: false, matchKanji: '' }] optional config\n * @return {String} text with okurigana removed\n * @example\n * stripOkurigana('踏み込む')\n * // => '踏み込'\n * stripOkurigana('お祝い')\n * // => 'お祝'\n * stripOkurigana('お腹', { leading: true });\n * // => '腹'\n * stripOkurigana('ふみこむ', { matchKanji: '踏み込む' });\n * // => 'ふみこ'\n * stripOkurigana('おみまい', { matchKanji: 'お祝い', leading: true });\n * // => 'みまい'\n */\nfunction stripOkurigana(input = '', { leading = false, matchKanji = '' } = {}) {\n  if (\n    !isJapanese(input) ||\n    isLeadingWithoutInitialKana(input, leading) ||\n    isTrailingWithoutFinalKana(input, leading) ||\n    isInvalidMatcher(input, matchKanji)\n  ) {\n    return input;\n  }\n\n  const chars = matchKanji || input;\n  const okuriganaRegex = new RegExp(\n    leading ? `^${tokenize(chars).shift()}` : `${tokenize(chars).pop()}$`\n  );\n  return input.replace(okuriganaRegex, '');\n}\n\nexport default stripOkurigana;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}